:AllowTypeErrors

// file 246
let rec cloneHelper x n l =
  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;
let rec clone x n = if n < 1 then [] else cloneHelper x n [];;
let padZero l1 l2 =
  let diff = (List.length l1) - (List.length l2) in
  if diff < 0
  then (((clone 0 (-1 * diff)) @ l1), l2)
  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = padZero l1 l2 in
    let base = List.combine l1 l2 in
    let args = failwith "to be implemented" in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `(_ * _) list` does not match `_ * _`
//│ 
//│         ((_ * _) list) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ ((_ * _) list) comes from
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ │  - l.16     let (_,res) = List.fold_left f base args in res in
//│ │                                            ^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.16     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ * _`
//│ 
//│         ((_ * _) list) ---> (?b) ~~~> (?b -> _ -> ?b) <--- (?a -> _ -> _)  ~~~> (?a) ~~~> (?a -> _ -> _) ---> (?b -> _ -> ?b)  <~~~ (?b) ---> (_ * _)
//│ 
//│ ◉ ((_ * _) list) comes from
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│   ◉ (?b -> _ -> ?b) comes from
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.16     let (_,res) = List.fold_left f base args in res in
//│   │                                          ^
//│   │ 
//│   ◉ (?a -> _ -> _) comes from
//│      - l.13     let f a x = padZero l1 l2 in
//│                       ^^^^^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│    - l.13     let f a x = padZero l1 l2 in
//│                     ^
//│   ◉ (?a -> _ -> _) comes from
//│   │  - l.13     let f a x = padZero l1 l2 in
//│   │                   ^^^^^^^^^^^^^^^^^^^
//│   │  - l.16     let (_,res) = List.fold_left f base args in res in
//│   │                                          ^
//│   ▼ 
//│   ◉ (?b -> _ -> ?b) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                   ^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.16     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ list * _`
//│ 
//│         ((_ * _) list) ---> (?b) <~~~ (_ -> ?b) <~~~  (?b -> _ -> ?b) <--- (_ -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <--- (_ list * _)
//│ 
//│ ◉ ((_ * _) list) comes from
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│   ◉ (_ -> ?b) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?b -> _ -> ?b) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?a) comes from
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list * _) comes from
//│    - l.7    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ * _ list`
//│ 
//│         ((_ * _) list) ---> (?c) <~~~ (_ -> ?c) <~~~  (?c -> _ -> ?c) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?a) <--- (_ * _ list)
//│ 
//│ ◉ ((_ * _) list) comes from
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│   ◉ (_ -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?c -> _ -> ?c) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) comes from
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ * _ list) comes from
//│    - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ * _`
//│ 
//│         ((_ * _) list) ---> (?c) <~~~ (_ -> ?c) <~~~  (?c -> _ -> ?c) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?a) <--- (_ * _)
//│ 
//│ ◉ ((_ * _) list) comes from
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│   ◉ (_ -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?c -> _ -> ?c) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) comes from
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ * _) comes from
//│    - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                    ^^^^^^^^
//│ [ERROR] Type `(_ * _) list` does not match `_ * _`
//│ 
//│         ((_ * _) list) ---> (?c) <~~~ (_ -> ?c) <~~~  (?c -> _ -> ?c) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?a) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?c -> _ -> ?c)  ~~~> (_ -> ?c)  ~~~> (?c) ---> (_ * _)
//│ 
//│ ◉ ((_ * _) list) comes from
//│ │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ │                                                  ^^^^^^^^^^^^^
//│ │  - l.14     let base = List.combine l1 l2 in
//│ │                        ^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│   ◉ (_ -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?c -> _ -> ?c) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) comes from
//│        - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ ▲  - l.6    if diff < 0
//│ │           ^^^^^^^^^^^
//│ │           then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.8    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.6    if diff < 0
//│             ^^^^^^^^^^^
//│             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.13     let f a x = padZero l1 l2 in
//│                         ^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?b) comes from
//│     │  - l.13     let f a x = padZero l1 l2 in
//│     │                   ^^^^^^^^^^^^^^^^^^^
//│     │  - l.16     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (?c -> _ -> ?c) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.16     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.16     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ cloneHelper: 'a -> int -> list['a] -> list['a]
//│ clone: 'b -> int -> 'c
//│   where
//│     'c = list['b], list['a], list['a0]
//│ padZero: list['a] -> list['b] -> (list['a], list['b],)
//│ removeZero: list[int] -> list[int]
//│ bigAdd: list['a] -> 'b -> list[int]
//│   where
//│     'b = list[int], list['c]
//│ U max: 33, total: 665
//│ UERR 6 errors
//│ L: 1 [list[([α203''], [α204''],)] ~ ([α212''], [α213''],), list[([α203''], [α204''],)] <: α206'', [α206'' - (α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])) - α208'', L: 0 [(α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])), (α206'' -> (α207'' -> α206'')) :> (α208'' -> (α209'' -> [α158'']))]], [α208'' - (α208'' -> (α209'' -> [α158''])) ~ (α206'' -> (α207'' -> α206'')) - α206'', L: 0 [(α208'' -> (α209'' -> [α158''])) ~ (α206'' -> (α207'' -> α206'')), (α208'' -> (α209'' -> [α158''])) <: (α206'' -> (α207'' -> α206''))]], α206'' <: ([α212''], [α213''],)]
//│ L: 2 [list[([α203''], [α204''],)] ~ ([[α151'']], [[α154'']],), list[([α203''], [α204''],)] <: α206'', [α206'' - (α207'' -> α206'') ~ (α209'' -> [α158'']) - α158'', L: 1 [(α207'' -> α206'') ~ (α209'' -> [α158'']), [(α207'' -> α206'') - (α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])) - (α209'' -> [α158'']), L: 0 [(α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])), (α206'' -> (α207'' -> α206'')) :> (α208'' -> (α209'' -> [α158'']))]]]], α158'' :> α157'', α157'' :> ([[α151'']], [[α154'']],)]
//│ L: 2 [list[([α203''], [α204''],)] ~ ([α212''], [α213''],), list[([α203''], [α204''],)] <: α206'', [α206'' - (α207'' -> α206'') ~ (α209'' -> [α158'']) - α158'', L: 1 [(α207'' -> α206'') ~ (α209'' -> [α158'']), [(α207'' -> α206'') - (α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])) - (α209'' -> [α158'']), L: 0 [(α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])), (α206'' -> (α207'' -> α206'')) :> (α208'' -> (α209'' -> [α158'']))]]]], α158'' :> α157'', α157'' <: α158'', [α158'' - (α209'' -> [α158'']) ~ (α207'' -> α206'') - α206'', L: 1 [(α209'' -> [α158'']) ~ (α207'' -> α206''), [(α209'' -> [α158'']) - (α208'' -> (α209'' -> [α158''])) ~ (α206'' -> (α207'' -> α206'')) - (α207'' -> α206''), L: 0 [(α208'' -> (α209'' -> [α158''])) ~ (α206'' -> (α207'' -> α206'')), (α208'' -> (α209'' -> [α158''])) <: (α206'' -> (α207'' -> α206''))]]]], α206'' <: ([α212''], [α213''],)]
//│ L: 2 [list[([α203''], [α204''],)] ~ ([[α151'']], [[list[α155'']]],), list[([α203''], [α204''],)] <: α206'', [α206'' - (α207'' -> α206'') ~ (α209'' -> [α158'']) - α158'', L: 1 [(α207'' -> α206'') ~ (α209'' -> [α158'']), [(α207'' -> α206'') - (α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])) - (α209'' -> [α158'']), L: 0 [(α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])), (α206'' -> (α207'' -> α206'')) :> (α208'' -> (α209'' -> [α158'']))]]]], α158'' :> α157'', α157'' :> ([[α151'']], [[list[α155'']]],)]
//│ L: 0 [list[([α203''], [α204''],)] ~ ([α212''], [α213''],), list[([α203''], [α204''],)] <: α206'', α206'' <: ([α212''], [α213''],)]
//│ L: 2 [list[([α203''], [α204''],)] ~ ([[list[α152'']]], [[α154'']],), list[([α203''], [α204''],)] <: α206'', [α206'' - (α207'' -> α206'') ~ (α209'' -> [α158'']) - α158'', L: 1 [(α207'' -> α206'') ~ (α209'' -> [α158'']), [(α207'' -> α206'') - (α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])) - (α209'' -> [α158'']), L: 0 [(α206'' -> (α207'' -> α206'')) ~ (α208'' -> (α209'' -> [α158''])), (α206'' -> (α207'' -> α206'')) :> (α208'' -> (α209'' -> [α158'']))]]]], α158'' :> ([[list[α152'']]], [[α154'']],)]


type expr =
    VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;
let pi = 4.0 *. (atan 1.0);;
let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;
//│ Defined type alias expr
//│ Defined class VarX
//│ Defined class VarY
//│ Defined class Sine
//│ Defined class Cosine
//│ Defined class Average
//│ Defined class Times
//│ Defined class Thresh
//│ [ERROR] Type `int` does not match `float`
//│ 
//│         (int) ---> (float)
//│ 
//│ ◉ (int) comes from
//│ │  - l.16   | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
//│ │                                                                           ^
//│ ▼ 
//│ ◉ (float) comes from
//│    - lib. let ( /. ): float -> float -> float
//│                                ^^^^^
//│ VarX: expr
//│ VarY: expr
//│ Sine: expr -> expr
//│ Cosine: expr -> expr
//│ Average: (expr, expr,) -> expr
//│ Times: (expr, expr,) -> expr
//│ Thresh: (expr, expr, expr, expr,) -> expr
//│ pi: float
//│ eval: (expr, float, float,) -> float
//│ U max: 14, total: 193
//│ UERR 1 errors
//│ L: 0 [int ~ float, int <: float]


let sqsum xs =
  let f a x = match x with | [] -> 0 | h::t -> 1 in
  let base = List.hd xs in List.fold_left f base xs;;
//│ [ERROR] Type `int` does not match `_ list`
//│ 
//│         (int) ---> (?b) ~~~> (?f -> ?b) ~~~>  (_ -> ?f -> ?b) ---> (?c -> ?d -> ?c)  ~~~> (?d -> ?c)  ~~~> (?c) <--- (?e) <~~~ (?e list) <--- (?a) ---> (?d list)  ~~~> (?d) <~~~ (?d -> ?c) <~~~  (?c -> ?d -> ?c) <--- (_ -> ?f -> ?b)  <~~~ (?f -> ?b)  ~~~> (?f) ---> (_ list)
//│ 
//│ ◉ (int) comes from
//│ │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ │                                            ^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (?f -> ?b) comes from
//│      - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?f -> ?b) comes from
//│     │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│     │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│     │                                                   ^
//│     ▼ 
//│     ◉ (?c -> ?d -> ?c) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (?d -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?c) is assumed for
//│ ▲  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│ │                                                     ^^^^
//│ │ 
//│ ◉ (?e) is assumed for
//│    - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│                        ^^^^^^^^^^
//│   ◉ (?e list) comes from
//│   ▲  - lib. let List.hd: 'a list -> 'a
//│   │                      ^^^^^^^
//│   │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│   │                              ^^
//│   │  - l.1  let sqsum xs =
//│   │                   ^^
//│   │ 
//│   ◉ (?a) is assumed for
//│   │  - l.1  let sqsum xs =
//│   │                   ^^
//│   │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│   │                                                          ^^
//│   ▼ 
//│   ◉ (?d list) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                                            ^^^^^^^
//│ ◉ (?d) is assumed for
//│   ◉ (?d -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?c -> ?d -> ?c) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.3    let base = List.hd xs in List.fold_left f base xs;;
//│     │                                                   ^
//│     │ 
//│     ◉ (_ -> ?f -> ?b) comes from
//│        - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (?f -> ?b) comes from
//│      - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?f) is assumed for
//│ │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ │                   ^
//│ │  - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│ │                             ^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - l.2    let f a x = match x with | [] -> 0 | h::t -> 1 in
//│                                        ^^
//│ sqsum: list['b] -> 'b
//│   where
//│     'b = int, list['a]
//│ U max: 5, total: 31
//│ UERR 1 errors
//│ L: 2 [int ~ list['a374'], int <: α375', [α375' - (α373' -> α375') ~ (α371' -> α370') - α370', L: 1 [(α373' -> α375') ~ (α371' -> α370'), [(α373' -> α375') - (α372' -> (α373' -> α375')) ~ (α370' -> (α371' -> α370')) - (α371' -> α370'), L: 0 [(α372' -> (α373' -> α375')) ~ (α370' -> (α371' -> α370')), (α372' -> (α373' -> α375')) <: (α370' -> (α371' -> α370'))]]]], α370' :> α369', [α369' - list[α369'] ~ list[α371'] - α371', L: 0 [list[α369'] ~ list[α371'], list[α369'] :> α364', α364' <: list[α371']]], [α371' - (α371' -> α370') ~ (α373' -> α375') - α373', L: 1 [(α371' -> α370') ~ (α373' -> α375'), [(α371' -> α370') - (α370' -> (α371' -> α370')) ~ (α372' -> (α373' -> α375')) - (α373' -> α375'), L: 0 [(α370' -> (α371' -> α370')) ~ (α372' -> (α373' -> α375')), (α370' -> (α371' -> α370')) :> (α372' -> (α373' -> α375'))]]]], α373' <: list['a374']]


// file 26 mod // TODO weird ctor arrow directions fix
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;
let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ [ERROR] Type `_ list` does not match `(_ -> _) -> _ list -> _ list`
//│ 
//│         (_ list) <--- (?b) <~~~ (?b -> _) ~~~>  (_ -> ?b -> _) ---> (?sepConcat) ---> (string -> ?a)  ~~~> (?a) ---> (((_ -> _) -> _ list -> _ list) -> _)  <~~~ ((_ -> _) -> _ list -> _ list)
//│ 
//│ ◉ (_ list) comes from
//│ ▲  - l.3    | [] -> ""
//│ │             ^^
//│ │  - l.2    match sl with
//│ │                 ^^
//│ │ 
//│ ◉ (?b) is assumed for
//│    - l.1  let rec sepConcat sep sl =
//│                                 ^^
//│   ◉ (?b -> _) comes from
//│      - l.1  let rec sepConcat sep sl =
//│                                   ^^^^
//│               match sl with ...
//│               ^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b -> _) comes from
//│     │  - l.1  let rec sepConcat sep sl =
//│     │                           ^^^^^^^^
//│     │           match sl with ...
//│     │           ^^^^^^^^^^^^^^^^^
//│     │  - l.1  let rec sepConcat sep sl =
//│     │                 ^^^^^^^^^
//│     ▼ 
//│     ◉ (?sepConcat) is assumed for
//│     │  - l.1  let rec sepConcat sep sl =
//│     │                 ^^^^^^^^^
//│     ▼ 
//│     ◉ (string -> ?a) comes from
//│        - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                              ^^^^^^^^^
//│   ◉ (?a) is assumed for
//│   │  - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│   │                                        ^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (((_ -> _) -> _ list -> _ list) -> _) comes from
//│      - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                            ^^^^^^^^^^^^^^
//│ ◉ ((_ -> _) -> _ list -> _ list) comes from
//│    - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                                         ^^^^^^^^
//│    - lib. let List.map: ('a -> 'b) -> 'a list -> 'b list
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `string` does not match `(_ * _) -> _`
//│ 
//│         (string) <--- (?a) ~~~> (?a -> _ -> string) ---> (?b -> _ -> ?b)  ~~~> (?b) ---> (?e) ~~~> (_ -> ?e) ~~~>  (_ -> _ -> ?e) ---> (?sepConcat) ---> (string -> ?d)  ~~~> (?d) ---> (((_ -> _) -> _ list -> _ list) -> ?c)  ~~~> (?c) ---> ((_ * _) -> _)
//│ 
//│ ◉ (string) comes from
//│ ▲  - lib. let (^): string -> string -> string
//│ │                  ^^^^^^
//│ │  - l.5        let f a x = a ^ (sep ^ x) in
//│ │                           ^
//│ │ 
//│ ◉ (?a) is assumed for
//│    - l.5        let f a x = a ^ (sep ^ x) in
//│                       ^
//│   ◉ (?a -> _ -> string) comes from
//│   │  - l.5        let f a x = a ^ (sep ^ x) in
//│   │                     ^^^^^^^^^^^^^^^^^^^
//│   │  - l.6        let base = h in let l = t in List.fold_left f base l;;
//│   │                                                           ^
//│   ▼ 
//│   ◉ (?b -> _ -> ?b) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                   ^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.6        let base = h in let l = t in List.fold_left f base l;;
//│ │                                            ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│    - l.2    match sl with
//│             ^^^^^^^^^^^^^
//│             | [] -> "" ...
//│             ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?e) comes from
//│      - l.1  let rec sepConcat sep sl =
//│                                   ^^^^
//│               match sl with ...
//│               ^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?e) comes from
//│     │  - l.1  let rec sepConcat sep sl =
//│     │                           ^^^^^^^^
//│     │           match sl with ...
//│     │           ^^^^^^^^^^^^^^^^^
//│     │  - l.1  let rec sepConcat sep sl =
//│     │                 ^^^^^^^^^
//│     ▼ 
//│     ◉ (?sepConcat) is assumed for
//│     │  - l.1  let rec sepConcat sep sl =
//│     │                 ^^^^^^^^^
//│     ▼ 
//│     ◉ (string -> ?d) comes from
//│        - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                              ^^^^^^^^^
//│   ◉ (?d) is assumed for
//│   │  - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│   │                                        ^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (((_ -> _) -> _ list -> _ list) -> ?c) comes from
//│      - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                            ^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ │                                        ^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ ((_ * _) -> _) comes from
//│    - l.7  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                          ^^^^^^^^^^^^^^^^^^^^^^^
//│ sepConcat: string -> list[string] -> string
//│ stringOfList: 'a -> 'b -> string
//│ U max: 7, total: 76
//│ UERR 2 errors
//│ L: 2 [list['a394'] ~ ((α401' -> α402') -> (list[α401'] -> list[α402'])), list['a394'] :> α393', [α393' - (α393' -> α399') ~ ([((α401' -> α402') -> (list[α401'] -> list[α402']))] -> α403') - ((α401' -> α402') -> (list[α401'] -> list[α402'])), L: 1 [(α393' -> α399') ~ ([((α401' -> α402') -> (list[α401'] -> list[α402']))] -> α403'), [(α393' -> α399') - (α392' -> (α393' -> α399')) ~ ([string] -> α400') - α400', L: 0 [(α392' -> (α393' -> α399')) ~ ([string] -> α400'), (α392' -> (α393' -> α399')) <: sepConcat391', sepConcat391' <: ([string] -> α400')]], α400' <: ([((α401' -> α402') -> (list[α401'] -> list[α402']))] -> α403')]]]
//│ L: 2 [string ~ (([[α389']], [[α390']],) -> α404'), string :> α398', [α398' - (α398' -> (α396' -> [string])) ~ (α397' -> (α395' -> α397')) - α397', L: 0 [(α398' -> (α396' -> [string])) ~ (α397' -> (α395' -> α397')), (α398' -> (α396' -> [string])) <: (α397' -> (α395' -> α397'))]], α397' <: α399', [α399' - (α393' -> α399') ~ ([((α401' -> α402') -> (list[α401'] -> list[α402']))] -> α403') - α403', L: 1 [(α393' -> α399') ~ ([((α401' -> α402') -> (list[α401'] -> list[α402']))] -> α403'), [(α393' -> α399') - (α392' -> (α393' -> α399')) ~ ([string] -> α400') - α400', L: 0 [(α392' -> (α393' -> α399')) ~ ([string] -> α400'), (α392' -> (α393' -> α399')) <: sepConcat391', sepConcat391' <: ([string] -> α400')]], α400' <: ([((α401' -> α402') -> (list[α401'] -> list[α402']))] -> α403')]], α403' <: (([[α389']], [[α390']],) -> α404')]

// file 1563 // TODO: weird ctor arrow directions fix
let rec sumListHelper total xs =
  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
let rec digitsOfIntHelper n =
  if n < 1
  then []
  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
let rec digitsOfInt n = digitsOfIntHelper n;;
let rec sumList xs = sumListHelper 0 xs;;
let rec additivePersistence n = sumList digitsOfInt n;;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) <~~~  (_ list -> _) <--- (?b) <~~~ (int -> ?b) <--- (?sumListHelper) ---> (int -> ?c)  ~~~> (?c) ---> (?a -> _)  (?a) ~~~> (?a -> _) ---> (?sumList) ---> (?digitsOfInt -> _)  <~~~ (?digitsOfInt) <--- (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│    - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                                                                                  ^^^^
//│   ◉ (_ list -> _) comes from
//│   ▲  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│   │                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed for
//│      - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (int -> ?b) comes from
//│     ▲  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│     │                                                     ^^^^^^^^^^^^^
//│     │  - l.1  let rec sumListHelper total xs =
//│     │                 ^^^^^^^^^^^^^
//│     │ 
//│     ◉ (?sumListHelper) is assumed for
//│     │  - l.1  let rec sumListHelper total xs =
//│     │                 ^^^^^^^^^^^^^
//│     ▼ 
//│     ◉ (int -> ?c) comes from
//│        - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                    ^^^^^^^^^^^^^
//│   ◉ (?c) is assumed for
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                              ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a -> _) comes from
//│      - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                  ^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│    - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                                ^^
//│    - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                           ^^
//│   ◉ (?a -> _) comes from
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                         ^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (?sumList) is assumed for
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (?digitsOfInt -> _) comes from
//│      - l.9  let rec additivePersistence n = sumList digitsOfInt n;;
//│                                             ^^^^^^^
//│ ◉ (?digitsOfInt) is assumed for
//│ ▲  - l.7  let rec digitsOfInt n = digitsOfIntHelper n;;
//│ │                 ^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) comes from
//│    - l.7  let rec digitsOfInt n = digitsOfIntHelper n;;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int` does not match `_ -> _`
//│ 
//│         (int) <~~~  (int -> ?d) <--- (?sumListHelper) <--- (?e -> _ -> ?b)  <~~~ (?e) ---> (?b) <--- (?f) <~~~ (_ list -> ?f) <--- (?g) <~~~ (int -> ?g) <--- (?sumListHelper) ---> (int -> ?d)  ~~~> (?d) ---> (_ -> ?c)  ~~~> (?c) <~~~ (_ -> ?c) ---> (?sumList) ---> (_ -> ?a)  ~~~> (?a) ---> (_ -> _)
//│ 
//│ ◉ (int) comes from
//│    - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                              ^
//│   ◉ (int -> ?d) comes from
//│   ▲  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                              ^^^^^^^^^^^^^
//│   │  - l.1  let rec sumListHelper total xs =
//│   │                 ^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?sumListHelper) is assumed for
//│   ▲  - l.1  let rec sumListHelper total xs =
//│   │                 ^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?e -> _ -> ?b) comes from
//│      - l.1  let rec sumListHelper total xs =
//│                                   ^^^^^^^^^^
//│               match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?e) is assumed for
//│ │  - l.1  let rec sumListHelper total xs =
//│ │                               ^^^^^
//│ │  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ │                                 ^^^^^
//│ │  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?f) is assumed for
//│    - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ list -> ?f) comes from
//│   ▲  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│   │                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?g) is assumed for
//│      - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (int -> ?g) comes from
//│     ▲  - l.2    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│     │                                                     ^^^^^^^^^^^^^
//│     │  - l.1  let rec sumListHelper total xs =
//│     │                 ^^^^^^^^^^^^^
//│     │ 
//│     ◉ (?sumListHelper) is assumed for
//│     │  - l.1  let rec sumListHelper total xs =
//│     │                 ^^^^^^^^^^^^^
//│     ▼ 
//│     ◉ (int -> ?d) comes from
//│        - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                    ^^^^^^^^^^^^^
//│   ◉ (?d) is assumed for
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                              ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?c) comes from
//│      - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                  ^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│    - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│                                ^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?c) comes from
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                         ^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (?sumList) is assumed for
//│   │  - l.8  let rec sumList xs = sumListHelper 0 xs;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?a) comes from
//│      - l.9  let rec additivePersistence n = sumList digitsOfInt n;;
//│                                             ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.9  let rec additivePersistence n = sumList digitsOfInt n;;
//│ │                                         ^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.9  let rec additivePersistence n = sumList digitsOfInt n;;
//│                                           ^^^^^^^^^^^^^^^^^^^
//│ sumListHelper: int -> list[int] -> int
//│ digitsOfIntHelper: int -> list[int]
//│ digitsOfInt: int -> list[int]
//│ sumList: list[int] -> int
//│ additivePersistence: 'a -> 'b
//│ U max: 20, total: 226
//│ UERR 2 errors
//│ L: 2 [int ~ ([α452'] -> α477'), [int - ([int] -> α462') ~ (α458' -> (α455' -> α456')) - α458', L: 0 [([int] -> α462') ~ (α458' -> (α455' -> α456')), ([int] -> α462') :> sumListHelper463', sumListHelper463' :> (α458' -> (α455' -> α456'))]], α458' <: α456', α456' :> α459', [α459' - ([list['a460']] -> α459') ~ ([α454'] -> α457') - α457', L: 1 [([list['a460']] -> α459') ~ ([α454'] -> α457'), ([list['a460']] -> α459') :> α461', [α461' - ([int] -> α461') ~ ([int] -> α462') - α462', L: 0 [([int] -> α461') ~ ([int] -> α462'), ([int] -> α461') :> sumListHelper463', sumListHelper463' <: ([int] -> α462')]], α462' <: ([α454'] -> α457')]], [α457' - (α454' -> α457') ~ ([digitsOfInt464'] -> α476') - α476', L: 0 [(α454' -> α457') ~ ([digitsOfInt464'] -> α476'), (α454' -> α457') <: sumList453', sumList453' <: ([digitsOfInt464'] -> α476')]], α476' <: ([α452'] -> α477')]
//│ L: 2 [list['a460'] ~ (α465' -> α475'), [list['a460'] - ([list['a460']] -> α459') ~ ([α454'] -> α457') - α454', L: 1 [([list['a460']] -> α459') ~ ([α454'] -> α457'), ([list['a460']] -> α459') :> α461', [α461' - ([int] -> α461') ~ ([int] -> α462') - α462', L: 0 [([int] -> α461') ~ ([int] -> α462'), ([int] -> α461') :> sumListHelper463', sumListHelper463' <: ([int] -> α462')]], α462' <: ([α454'] -> α457')]], [α454' - (α454' -> α457') ~ ([digitsOfInt464'] -> α476') - digitsOfInt464', L: 0 [(α454' -> α457') ~ ([digitsOfInt464'] -> α476'), (α454' -> α457') <: sumList453', sumList453' <: ([digitsOfInt464'] -> α476')]], digitsOfInt464' :> (α465' -> α475')]

// file 8776
// TODO list indexing here. skip this example?
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
let rec matchHeads x =
  match explode x with
  | h::t ->
      if (getHeads (explode x)) = []
      then true
      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ [ERROR] Type `err` does not match `_ -> _`
//│ 
//│         (err) ---> (_ -> _)
//│ 
//│ ◉ (err) comes from
//│ │  - l.6    match explode x with
//│ │                 ^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.6    match explode x with
//│                   ^^^^^^^
//│ [ERROR] Type `err` does not match `_ -> _`
//│ 
//│         (err) ---> (_ -> _)
//│ 
//│ ◉ (err) comes from
//│ │  - l.8        if (getHeads (explode x)) = []
//│ │                             ^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.8        if (getHeads (explode x)) = []
//│                               ^^^^^^^
//│ listReverse: list['a] -> list['a]
//│ getHeads: list['a] -> list['a]
//│ loseTail: list['a] -> list['a]
//│ ╔══[ERROR] identifier not found: explode
//│ ║  
//│ ║  l.728:	  match explode x with
//│ ╙──      	        ^^^^^^^
//│ ╔══[ERROR] identifier not found: explode
//│ ║  
//│ ║  l.730:	      if (getHeads (explode x)) = []
//│ ╙──      	                    ^^^^^^^
//│ matchHeads: 'a -> bool
//│ U max: 10, total: 205
//│ UERR 2 errors
//│ L: 0 [err ~ ([α516'] -> α517'), err <: ([α516'] -> α517')]
//│ L: 0 [err ~ ([α516'] -> α533'), err <: ([α516'] -> α533')]

// TODO: parse correctly
let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;
//│ [ERROR] Type `err` does not match `_ -> _`
//│ 
//│         (err) ---> (_ -> _)
//│ 
//│ ◉ (err) comes from
//│ │  - l.3      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ │                      ^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.3      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                        ^^^^^^^^^^^^^
//│ [ERROR] Type `err` does not match `_ list -> _`
//│ 
//│         (err) ---> (_ list -> _)
//│ 
//│ ◉ (err) comes from
//│ │  - l.3      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ │                                                     ^^
//│ ▼ 
//│ ◉ (_ list -> _) comes from
//│    - l.3      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                                                       ^^
//│ ╔══[ERROR] identifier not found: String.length
//│ ║  
//│ ║  l.775:	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ╙──      	             ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: s.
//│ ║  
//│ ║  l.775:	    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│ ╙──      	                                            ^^
//│ explode: 'a -> list['b]
//│ U max: 6, total: 56
//│ UERR 2 errors
//│ L: 0 [err ~ (list[[α567'']] -> α573''), err <: (list[[α567'']] -> α573'')]
//│ L: 0 [err ~ ([α565'] -> α569''), err <: ([α565'] -> α569'')]

// file 89
// TODO: parse properly
let rec digitsOfInt n =
  let return = [n mod 10] in
  if (n / 10) <> 0
  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
  else return;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t)
let rec digitalRoot n =
  let digits = digitsOfInt n in
  let s = sumList digits in
  if (n / 10) <> 0
  then (print_int n; print_endline " "; digitalRoot)
  else digits;;
//│ /!\ Parse error: Expected ")":4:29, found "; (digitsO" at l.818:29:   then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)

// file 2361
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?b) ---> (?a) <--- (int)
//│ 
//│ ◉ (bool) comes from
//│ │  - l.8    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                                                       ^^^^^
//│ │  - l.8    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.8    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.6    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.6    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - l.7    | [] -> 0
//│                     ^
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]
//│ additivePersistence: 'a -> 'b
//│   where
//│     'b = bool, int
//│ U max: 5, total: 115
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool <: α635', α635' <: α625', α625' :> int]


// file 358 mod
// type expr used from previous
let buildCosine e = Cosine e;;
let buildSine e = Sine e;;
let buildX () = VarX;;
let buildY () = VarY;;
let rec build (rand,depth) =
  let r = rand 0.4 in
  match depth with
  | 0 -> if (r mod 2) = 0 then buildX else buildY
  | d ->
      if r = 0
      then buildSine build (rand, (d - 1))
      else buildCosine build (rand, (d - 1));;
//│ [ERROR] Type `expr` does not match `(_ * int) -> _`
//│ 
//│         (expr) ---> ((_ * int) -> _)
//│ 
//│ ◉ (expr) comes from
//│ │  - l.-580  | Thresh of expr* expr* expr* expr;;
//│ │              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2  let buildSine e = Sine e;;
//│ │                           ^^^^^^
//│ ▼ 
//│ ◉ ((_ * int) -> _) comes from
//│    - l.11       then buildSine build (rand, (d - 1))
//│                      ^^^^^^^^^^^^^^^
//│ [ERROR] Type `expr` does not match `(_ * int) -> _`
//│ 
//│         (expr) ---> ((_ * int) -> _)
//│ 
//│ ◉ (expr) comes from
//│ │  - l.-580  | Thresh of expr* expr* expr* expr;;
//│ │              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.1  let buildCosine e = Cosine e;;
//│ │                             ^^^^^^^^
//│ ▼ 
//│ ◉ ((_ * int) -> _) comes from
//│    - l.12       else buildCosine build (rand, (d - 1));;
//│                      ^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `(_ * _) -> _` does not match `expr`
//│ 
//│         ((_ * _) -> _) ---> (?build) ---> (?b) <--- (?build) ---> (?a) ---> (expr)
//│ 
//│ ◉ ((_ * _) -> _) comes from
//│ │  - l.5  let rec build (rand,depth) =
//│ │                       ^^^^^^^^^^^^^^
//│ │           let r = rand 0.4 in ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5  let rec build (rand,depth) =
//│ │                 ^^^^^
//│ ▼ 
//│ ◉ (?build) is assumed for
//│ │  - l.5  let rec build (rand,depth) =
//│ │                 ^^^^^
//│ │  - l.12       else buildCosine build (rand, (d - 1));;
//│ │                                ^^^^^
//│ │  - l.1  let buildCosine e = Cosine e;;
//│ │                         ^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.1  let buildCosine e = Cosine e;;
//│ │                         ^
//│ │  - l.12       else buildCosine build (rand, (d - 1));;
//│ │                                ^^^^^
//│ │  - l.5  let rec build (rand,depth) =
//│ │                 ^^^^^
//│ │ 
//│ ◉ (?build) is assumed for
//│ │  - l.5  let rec build (rand,depth) =
//│ │                 ^^^^^
//│ │  - l.11       then buildSine build (rand, (d - 1))
//│ │                              ^^^^^
//│ │  - l.2  let buildSine e = Sine e;;
//│ │                       ^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.2  let buildSine e = Sine e;;
//│ │                       ^
//│ │  - l.2  let buildSine e = Sine e;;
//│ │                                ^
//│ ▼ 
//│ ◉ (expr) comes from
//│    - l.-584  | Sine of expr
//│                        ^^^^
//│ buildCosine: expr -> expr
//│ buildSine: expr -> expr
//│ buildX: () -> expr
//│ buildY: () -> expr
//│ build: 'build
//│   where
//│     'build = (float -> int, int,) -> () -> expr, expr
//│ U max: 3, total: 31
//│ UERR 3 errors
//│ L: 0 [expr ~ (([[α641']], [[int]],) -> α650'), expr <: (([[α641']], [[int]],) -> α650')]
//│ L: 0 [(([α641'], [α642'],) -> α644') ~ expr, (([α641'], [α642'],) -> α644') <: build640', build640' <: α651', α651' :> build640', build640' <: α649', α649' <: expr]
//│ L: 0 [expr ~ (([[α641']], [[int]],) -> α652'), expr <: (([[α641']], [[int]],) -> α652')]

// TODO file 1337 in separate file to avoid collisions

// file 2752 mod
let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
let x l = List.map string_of_int;;
let y = [1, 2, 3];;
let rec mulByDigit i l =
  match List.rev l with
  | [] -> []
  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ [ERROR] Type `_ -> _ list -> _ list` does not match `int`
//│ 
//│         (_ -> _ list -> _ list) ---> (?a) ---> (int)
//│ 
//│ ◉ (_ -> _ list -> _ list) comes from
//│ │  - l.2  let x l = List.map string_of_int;;
//│ │               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ │                                ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                       ^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                       ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                                 ^
//│ ▼ 
//│ ◉ (int) comes from
//│    - lib. let ( * ): int -> int -> int
//│                      ^^^
//│ [ERROR] Type `(int * int * int) list` does not match `int`
//│ 
//│         ((int * int * int) list) ---> (?a) ---> (int)
//│ 
//│ ◉ ((int * int * int) list) comes from
//│ │  - l.3  let y = [1, 2, 3];;
//│ │                 ^^^^^^^^^
//│ │  - l.7    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ │                                  ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                         ^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                         ^
//│ │  - l.1  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│ │                                     ^
//│ ▼ 
//│ ◉ (int) comes from
//│    - lib. let ( * ): int -> int -> int
//│                             ^^^
//│ remainder: int -> int -> int
//│ x: 'a -> list[int] -> list[string]
//│ y: list[(int, int, int,)]
//│ mulByDigit: 'b -> list['a] -> list[int]
//│ U max: 5, total: 55
//│ UERR 2 errors
//│ L: 0 [list[([[int]], [[int]], [[int]],)] ~ int, list[([[int]], [[int]], [[int]],)] <: α672', α672' <: int]
//│ L: 0 [(α674' -> [(list[α675'] -> list[α676'])]) ~ int, (α674' -> [(list[α675'] -> list[α676'])]) <: α671', α671' <: int]


// file 344 mod
let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
let padLength l1 l2 = abs ((List.length l1) - (List.length l2));;
let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then (clone 0 (padLength l1 l2)) :: l1
  else (clone 0 (padLength l1 l2)) l2;;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (?d) ~~~> (_ -> ?d) ~~~>  (_ -> _ -> ?d) ---> (?clone) ---> (_ -> ?a)  ~~~> (?a) ---> (int -> ?c)  ~~~> (?c) ~~~> (int -> ?c) <--- (?a) <~~~ (_ -> ?a) <--- (?clone) ---> (int -> ?e)  ~~~> (?e) <~~~ (int -> ?e) <--- (?clone) <--- (_ -> _ -> ?d)  <~~~ (_ -> ?d)  <~~~ (?d) <~~~ (_ -> ?d) ~~~>  (_ -> _ -> ?d) ---> (?clone) ---> (int -> ?e)  (?e) ~~~> (int -> ?e) <--- (?clone) ---> (_ -> ?a)  ~~~> (?a) ---> (int -> ?c)  ~~~> (?c) ~~~> (int -> ?c) <--- (?a) <~~~ (_ -> ?a) <--- (?clone) ---> (int -> ?e)  ~~~> (?e) ---> (int -> ?b)  ~~~> (?b) ---> (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ │                                                                       ^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?d) comes from
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (_ -> ?a) comes from
//│        - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                       ^^^^^
//│   ◉ (?a) is assumed for
//│   │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?c) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│ ◉ (?c) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                  ^^^^^^^^^^^^^^^^^
//│   ◉ (int -> ?c) comes from
//│   ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   │ 
//│   ◉ (?a) is assumed for
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│     ◉ (_ -> ?a) comes from
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                                                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?e) comes from
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?e) is assumed for
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│     ◉ (int -> ?e) comes from
//│     ▲  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│     │                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (_ -> _ -> ?d) comes from
//│        - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?d) comes from
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?e) comes from
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?e) is assumed for
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│     ◉ (int -> ?e) comes from
//│     ▲  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│     │                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (_ -> ?a) comes from
//│        - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                       ^^^^^
//│   ◉ (?a) is assumed for
//│   │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?c) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│ ◉ (?c) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                  ^^^^^^^^^^^^^^^^^
//│   ◉ (int -> ?c) comes from
//│   ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   │ 
//│   ◉ (?a) is assumed for
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│     ◉ (_ -> ?a) comes from
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                                                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?e) comes from
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?e) is assumed for
//│   │  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?b) comes from
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (?d) ~~~> (_ -> ?d) ~~~>  (_ -> _ -> ?d) ---> (?clone) ---> (_ -> ?a)  ~~~> (?a) ---> (int -> ?c)  ~~~> (?c) ~~~> (int -> ?c) <--- (?a) <~~~ (_ -> ?a) <--- (?clone) ---> (int -> ?e)  ~~~> (?e) <~~~ (int -> ?e) <--- (?clone) <--- (_ -> _ -> ?d)  <~~~ (_ -> ?d)  <~~~ (?d) <~~~ (_ -> ?d) ~~~>  (_ -> _ -> ?d) ---> (?clone) ---> (int -> ?e)  (?e) ~~~> (int -> ?e) <--- (?clone) ---> (_ -> ?a)  ~~~> (?a) ---> (int -> ?c)  ~~~> (?c) ~~~> (int -> ?c) <--- (?a) <~~~ (_ -> ?a) <--- (?clone) ---> (int -> ?e)  ~~~> (?e) ---> (int -> ?b)  ~~~> (?b) ---> (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│ │                                           ^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?d) comes from
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (_ -> ?a) comes from
//│        - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                       ^^^^^
//│   ◉ (?a) is assumed for
//│   │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?c) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│ ◉ (?c) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                  ^^^^^^^^^^^^^^^^^
//│   ◉ (int -> ?c) comes from
//│   ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   │ 
//│   ◉ (?a) is assumed for
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│     ◉ (_ -> ?a) comes from
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                                                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?e) comes from
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?e) is assumed for
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│     ◉ (int -> ?e) comes from
//│     ▲  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│     │                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (_ -> _ -> ?d) comes from
//│        - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?d) comes from
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?e) comes from
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?e) is assumed for
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│     ◉ (int -> ?e) comes from
//│     ▲  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│     │                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (_ -> ?a) comes from
//│        - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                       ^^^^^
//│   ◉ (?a) is assumed for
//│   │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?c) comes from
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│ ◉ (?c) is assumed for
//│    - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                  ^^^^^^^^^^^^^^^^^
//│   ◉ (int -> ?c) comes from
//│   ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│   │                                                 ^^^^^^^
//│   │ 
//│   ◉ (?a) is assumed for
//│      - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                     ^^^^^^^
//│     ◉ (_ -> ?a) comes from
//│     ▲  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                                                 ^^^^^
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     │ 
//│     ◉ (?clone) is assumed for
//│     │  - l.1  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│     │                 ^^^^^
//│     ▼ 
//│     ◉ (int -> ?e) comes from
//│        - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                       ^^^^^
//│   ◉ (?e) is assumed for
//│   │  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (int -> ?b) comes from
//│      - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                     ^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│ │                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.6    else (clone 0 (padLength l1 l2)) l2;;
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padLength: list['a] -> list['b] -> int
//│ padZero: list[list[int]] -> list['a] -> list[list[int]]
//│ U max: 11, total: 195
//│ UERR 2 errors
//│ L: 2 [list[[α724']] ~ ([α702'] -> α738'), list[[α724']] <: α726', [α726' - (α728' -> α726') ~ ([int] -> α727') - α727', L: 1 [(α728' -> α726') ~ ([int] -> α727'), [(α728' -> α726') - (α724' -> (α728' -> α726')) ~ ([α724'] -> α729') - α729', L: 0 [(α724' -> (α728' -> α726')) ~ ([α724'] -> α729'), (α724' -> (α728' -> α726')) <: clone723', clone723' <: ([α724'] -> α729')]], α729' <: ([int] -> α727')]], [α727' - ([int] -> α727') ~ (α728' -> α726') - α726', L: 1 [([int] -> α727') ~ (α728' -> α726'), ([int] -> α727') :> α729', [α729' - ([α724'] -> α729') ~ ([int] -> α732') - α732', L: 0 [([α724'] -> α729') ~ ([int] -> α732'), ([α724'] -> α729') :> clone723', clone723' <: ([int] -> α732')]], [α732' - ([int] -> α732') ~ (α724' -> (α728' -> α726')) - (α728' -> α726'), L: 0 [([int] -> α732') ~ (α724' -> (α728' -> α726')), ([int] -> α732') :> clone723', clone723' :> (α724' -> (α728' -> α726'))]]]], [α726' - (α728' -> α726') ~ ([int] -> α727') - α727', L: 1 [(α728' -> α726') ~ ([int] -> α727'), [(α728' -> α726') - (α724' -> (α728' -> α726')) ~ ([int] -> α732') - α732', L: 0 [(α724' -> (α728' -> α726')) ~ ([int] -> α732'), (α724' -> (α728' -> α726')) <: clone723', clone723' <: ([int] -> α732')]], [α732' - ([int] -> α732') ~ ([α724'] -> α729') - α729', L: 0 [([int] -> α732') ~ ([α724'] -> α729'), ([int] -> α732') :> clone723', clone723' <: ([α724'] -> α729')]], α729' <: ([int] -> α727')]], [α727' - ([int] -> α727') ~ ([[int]] -> α737') - α737', L: 1 [([int] -> α727') ~ ([[int]] -> α737'), ([int] -> α727') :> α729', [α729' - ([α724'] -> α729') ~ ([int] -> α732') - α732', L: 0 [([α724'] -> α729') ~ ([int] -> α732'), ([α724'] -> α729') :> clone723', clone723' <: ([int] -> α732')]], α732' <: ([[int]] -> α737')]], α737' <: ([α702'] -> α738')]
//│ L: 2 [list['a725'] ~ ([α702'] -> α738'), list['a725'] <: α726', [α726' - (α728' -> α726') ~ ([int] -> α727') - α727', L: 1 [(α728' -> α726') ~ ([int] -> α727'), [(α728' -> α726') - (α724' -> (α728' -> α726')) ~ ([α724'] -> α729') - α729', L: 0 [(α724' -> (α728' -> α726')) ~ ([α724'] -> α729'), (α724' -> (α728' -> α726')) <: clone723', clone723' <: ([α724'] -> α729')]], α729' <: ([int] -> α727')]], [α727' - ([int] -> α727') ~ (α728' -> α726') - α726', L: 1 [([int] -> α727') ~ (α728' -> α726'), ([int] -> α727') :> α729', [α729' - ([α724'] -> α729') ~ ([int] -> α732') - α732', L: 0 [([α724'] -> α729') ~ ([int] -> α732'), ([α724'] -> α729') :> clone723', clone723' <: ([int] -> α732')]], [α732' - ([int] -> α732') ~ (α724' -> (α728' -> α726')) - (α728' -> α726'), L: 0 [([int] -> α732') ~ (α724' -> (α728' -> α726')), ([int] -> α732') :> clone723', clone723' :> (α724' -> (α728' -> α726'))]]]], [α726' - (α728' -> α726') ~ ([int] -> α727') - α727', L: 1 [(α728' -> α726') ~ ([int] -> α727'), [(α728' -> α726') - (α724' -> (α728' -> α726')) ~ ([int] -> α732') - α732', L: 0 [(α724' -> (α728' -> α726')) ~ ([int] -> α732'), (α724' -> (α728' -> α726')) <: clone723', clone723' <: ([int] -> α732')]], [α732' - ([int] -> α732') ~ ([α724'] -> α729') - α729', L: 0 [([int] -> α732') ~ ([α724'] -> α729'), ([int] -> α732') :> clone723', clone723' <: ([α724'] -> α729')]], α729' <: ([int] -> α727')]], [α727' - ([int] -> α727') ~ ([[int]] -> α737') - α737', L: 1 [([int] -> α727') ~ ([[int]] -> α737'), ([int] -> α727') :> α729', [α729' - ([α724'] -> α729') ~ ([int] -> α732') - α732', L: 0 [([α724'] -> α729') ~ ([int] -> α732'), ([α724'] -> α729') :> clone723', clone723' <: ([int] -> α732')]], α732' <: ([[int]] -> α737')]], α737' <: ([α702'] -> α738')]

// file 2736 [TODO different part of file has errors]
let rec addHelper (t,u) =
 match List.rev t with
 | [] -> []
 | h::t ->
    match List.rev u with
     | [] -> []
     | h'::t' ->
         if (h + h') > 10
         then (addHelper (t, t')) @ [(1 + h') + h]
         else (addHelper (t, t')) @ [h' + h];;
//│ addHelper: (list[int], list[int],) -> list[int]



// file 1948
let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) ---> (?a) <--- (_ list)
//│ 
//│ ◉ (_ -> _) comes from
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                         ^^^^
//│ │             let add (l1,l2) = ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) comes from
//│    - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1368  let diff = (List.length l1) - (List.length l2) in
//│ │                                     ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│ │                                            ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?e) ---> (?b) ~~~> (?b * _ list) ---> (?c) ---> (?d) ---> (?a * _)  ~~~> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?b * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1359    let base = List.combine l1 l2 in
//│ │                                       ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?e) ---> (?b) ~~~> (?b * _ list) ---> (?c) ---> (?d) ---> (?a * _)  ~~~> (?a) ---> (?f) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?b * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ ▼ 
//│ ◉ (?f) is assumed for
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1368  let diff = (List.length l1) - (List.length l2) in
//│ │                                     ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?e) ---> (?b) ~~~> (?b * _ list) ---> (?c) ---> (?d) ---> (?a * _)  ~~~> (?a) ~~~> (?a * _) <--- (?d) <--- (_ list * _)  <~~~ (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?b * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│    - l.-1361  let add (l1,l2) =
//│                        ^^
//│   ◉ (?a * _) comes from
//│   ▲  - l.-1361  let add (l1,l2) =
//│   │                     ^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) comes from
//│      - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (_ list) comes from
//│    - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                                          ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?f) ---> (?c) ~~~> (?c * _ list) ---> (?d) ---> (?e) ---> (?a * _)  ~~~> (?a) ---> (?g) ~~~> (?g * _) ---> (?h) ---> (?b) <--- (_ list * _)  <~~~ (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?f) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?c * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ ▼ 
//│ ◉ (?g) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?g * _) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                    ^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?h) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) comes from
//│      - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (_ list) comes from
//│    - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                                          ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?e) ---> (?b) ~~~> (?b * _ list) ---> (?c) ---> (?d) ---> (?a * _)  ~~~> (?a) ~~~> (?a * _) <--- (?d) <--- (?c) <--- (?b * _ list)  <~~~ (?b) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?b * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│    - l.-1361  let add (l1,l2) =
//│                        ^^
//│   ◉ (?a * _) comes from
//│   ▲  - l.-1361  let add (l1,l2) =
//│   │                     ^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?c) is assumed for
//│   ▲  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b * _ list) comes from
//│      - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1368  let diff = (List.length l1) - (List.length l2) in
//│ │                                     ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ -> _`
//│ 
//│         (int * _ list) ---> (?d) <~~~ (_ -> ?d) <~~~  (?d -> _ -> ?d) <--- (_ -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <--- (?c) <--- (?b) <--- (_ -> _)
//│ 
//│ ◉ (int * _ list) comes from
//│ │  - l.9    let base = (0, []) in
//│ │                      ^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│   ◉ (_ -> ?d) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?d -> _ -> ?d) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?a) comes from
//│        - l.5    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ ▲  - l.6      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) comes from
//│    - l.-1362let bigAdd l1 l2 =
//│                           ^^^^
//│               let add (l1,l2) = ...
//│               ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ list`
//│ 
//│         (int * _ list) ---> (?d) <~~~ (_ -> ?d) <~~~  (?d -> _ -> ?d) <--- (_ -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <--- (?c) <--- (?b) <--- (_ list)
//│ 
//│ ◉ (int * _ list) comes from
//│ │  - l.9    let base = (0, []) in
//│ │                      ^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│   ◉ (_ -> ?d) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?d -> _ -> ?d) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?a) comes from
//│        - l.5    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ ▲  - l.6      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) comes from
//│    - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?b) ---> (?c) ---> (?a) ~~~> (_ -> ?a) ~~~>  (_ -> _ -> ?a) ---> (?d -> _ -> ?d)  ~~~> (_ -> ?d)  ~~~> (?d) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) comes from
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                         ^^^^
//│ │             let add (l1,l2) = ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?a) comes from
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?d -> _ -> ?d) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?d) is assumed for
//│ │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ~~~>  (_ list -> _) <--- (?a) <~~~ (_ -> ?a) <--- (?mulByDigit) ---> (_ -> ?b)  ~~~> (?b) ---> (?c -> _)  <~~~ (?c) ---> (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│    - l.-393  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│                                                        ^
//│   ◉ (_ list -> _) comes from
//│   ▲  - l.-393  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│   │                                         ^^^^^^^^^^^^
//│   │ 
//│   ◉ (?a) is assumed for
//│      - l.-393  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│                                             ^^^^^^^^^^^^
//│     ◉ (_ -> ?a) comes from
//│     ▲  - l.-393  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│     │                                         ^^^^^^^^^^
//│     │  - l.-396let rec mulByDigit i l =
//│     │                  ^^^^^^^^^^
//│     │ 
//│     ◉ (?mulByDigit) is assumed for
//│     │  - l.-396let rec mulByDigit i l =
//│     │                  ^^^^^^^^^^
//│     ▼ 
//│     ◉ (_ -> ?b) comes from
//│        - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                               ^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c -> _) comes from
//│      - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                             ^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.4  let bigMul l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.10   let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?b) ---> (?c) ---> (?a) ~~~> (_ -> ?a) ~~~>  (_ -> _ -> ?a) ---> (?d -> _ -> ?d)  ~~~> (_ -> ?d)  ~~~> (?d) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?a) comes from
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?d -> _ -> ?d) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?d) is assumed for
//│ │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) <--- (?c) <~~~ (?c -> _) ~~~>  (_ -> ?c -> _) ---> (?mulByDigit) ---> (_ -> ?a)  ~~~> (?a) ---> (?b -> _)  <~~~ (?b) ---> (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ ▲  - lib. let List.rev: 'a list -> 'a list
//│ │                       ^^^^^^^
//│ │  - l.-395  match List.rev l with
//│ │                           ^
//│ │ 
//│ ◉ (?c) is assumed for
//│    - l.-396let rec mulByDigit i l =
//│                                 ^
//│   ◉ (?c -> _) comes from
//│      - l.-396let rec mulByDigit i l =
//│                                   ^^^
//│                match List.rev l with ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?c -> _) comes from
//│     │  - l.-396let rec mulByDigit i l =
//│     │                             ^^^^^
//│     │            match List.rev l with ...
//│     │            ^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.-396let rec mulByDigit i l =
//│     │                  ^^^^^^^^^^
//│     ▼ 
//│     ◉ (?mulByDigit) is assumed for
//│     │  - l.-396let rec mulByDigit i l =
//│     │                  ^^^^^^^^^^
//│     ▼ 
//│     ◉ (_ -> ?a) comes from
//│        - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                               ^^^^^^^^^^
//│   ◉ (?a) is assumed for
//│   │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b -> _) comes from
//│      - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                             ^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.4  let bigMul l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.10   let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?a) ---> (?d) ---> (?e) ~~~> (_ -> ?e) ~~~>  (?b -> _ -> ?e) ---> (?c -> _ -> ?c)  ~~~> (_ -> ?c)  ~~~> (?c) ~~~> (?c -> _ -> ?c) <--- (?b -> _ -> ?e)  ~~~> (?b) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) comes from
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                         ^^^^
//│ │             let add (l1,l2) = ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?e) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (?b -> _ -> ?e) comes from
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?c -> _ -> ?c) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?c) is assumed for
//│   ◉ (?c -> _ -> ?c) comes from
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│   │                                            ^
//│   │ 
//│   ◉ (?b -> _ -> ?e) comes from
//│      - l.5    let f a x =
//│                     ^^^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.5    let f a x =
//│ │                 ^
//│ │  - l.7      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.7      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) ---> (?d) ---> (?e) ~~~> (_ -> ?e) ~~~>  (?b -> _ -> ?e) ---> (?c -> _ -> ?c)  ~~~> (_ -> ?c)  ~~~> (?c) ~~~> (?c -> _ -> ?c) <--- (?b -> _ -> ?e)  ~~~> (?b) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?e) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (?b -> _ -> ?e) comes from
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?c -> _ -> ?c) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?c) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?c) is assumed for
//│   ◉ (?c -> _ -> ?c) comes from
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│   │                                            ^
//│   │ 
//│   ◉ (?b -> _ -> ?e) comes from
//│      - l.5    let f a x =
//│                     ^^^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ │  - l.5    let f a x =
//│ │                 ^
//│ │  - l.7      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.7      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (?b) ---> (?c) ---> (?a) ~~~> (_ -> ?a) ~~~>  (_ -> _ -> ?a) ---> (?d -> _ -> ?d)  ~~~> (_ -> ?d)  ~~~> (?d) ~~~> (_ -> ?d) <~~~  (?d -> _ -> ?d) <--- (_ -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <--- (?c) <--- (?b) <--- (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.6      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?a) comes from
//│     │  - l.5    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?d -> _ -> ?d) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?d) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?d) is assumed for
//│   ◉ (_ -> ?d) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?d -> _ -> ?d) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.11   let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?a) comes from
//│        - l.5    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - l.5    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ ▲  - l.6      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.7      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) comes from
//│    - l.-1362let bigAdd l1 l2 =
//│                           ^^^^
//│               let add (l1,l2) = ...
//│               ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?f) ---> (?c) ~~~> (?c * _ list) ---> (?d) ---> (?e) ---> (?a * _)  ~~~> (?a) ---> (?g) ~~~> (?g * _) ---> (?i) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?h -> _ -> ?h)  ~~~> (_ -> ?h)  ~~~> (?h) ~~~> (_ -> ?h) <~~~  (?h -> _ -> ?h) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (_ list * _)  <~~~ (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?f) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?c * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ ▼ 
//│ ◉ (?g) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?g * _) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                    ^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?i) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│      - l.-1367  if diff < 0
//│                 ^^^^^^^^^^^
//│                 then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?b) comes from
//│       │  - l.-1360    let f a x = padZero l1 l2 in
//│       │                     ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       ▼ 
//│       ◉ (?h -> _ -> ?h) comes from
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│     ◉ (_ -> ?h) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│   ◉ (?h) is assumed for
//│     ◉ (_ -> ?h) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│       ◉ (?h -> _ -> ?h) comes from
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       │ 
//│       ◉ (_ -> _ -> ?b) comes from
//│          - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) comes from
//│      - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (_ list) comes from
//│    - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                                          ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?g) ---> (?c) ~~~> (?c * _ list) ---> (?e) ---> (?f) ---> (?a * _)  ~~~> (?a) ---> (?h) ~~~> (?h * _) ---> (?j) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?i -> _ -> ?i)  ~~~> (_ -> ?i)  ~~~> (?i) ---> (?d * _)  ~~~> (?d) ~~~> (?d * _) <--- (?i) <~~~ (_ -> ?i) <~~~  (?i -> _ -> ?i) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?j) <--- (?h * _)  <~~~ (?h) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?g) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?c * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?f) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ ▼ 
//│ ◉ (?h) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?h * _) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                    ^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│      - l.-1367  if diff < 0
//│                 ^^^^^^^^^^^
//│                 then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?b) comes from
//│       │  - l.-1360    let f a x = padZero l1 l2 in
//│       │                     ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) comes from
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│   ◉ (?i) is assumed for
//│   │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d * _) comes from
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                       ^^^^^^^
//│ ◉ (?d) is assumed for
//│    - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                      ^
//│   ◉ (?d * _) comes from
//│   ▲  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                   ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed for
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│       ◉ (?i -> _ -> ?i) comes from
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       │ 
//│       ◉ (_ -> _ -> ?b) comes from
//│          - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?j) is assumed for
//│   ▲  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?h * _) comes from
//│      - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^^^^^^^
//│ ◉ (?h) is assumed for
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1368  let diff = (List.length l1) - (List.length l2) in
//│ │                                     ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?g) ---> (?c) ~~~> (?c * _ list) ---> (?e) ---> (?f) ---> (?a * _)  ~~~> (?a) ---> (?h) ~~~> (?h * _) ---> (?j) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?i -> _ -> ?i)  ~~~> (_ -> ?i)  ~~~> (?i) ---> (?d * _)  ~~~> (?d) ~~~> (?d * _) <--- (?i) <~~~ (_ -> ?i) <~~~  (?i -> _ -> ?i) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?j) <--- (?h * _)  <~~~ (?h) <--- (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?g) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?c * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?f) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ ▼ 
//│ ◉ (?h) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?h * _) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                    ^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│      - l.-1367  if diff < 0
//│                 ^^^^^^^^^^^
//│                 then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?b) comes from
//│       │  - l.-1360    let f a x = padZero l1 l2 in
//│       │                     ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) comes from
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│   ◉ (?i) is assumed for
//│   │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d * _) comes from
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                       ^^^^^^^
//│ ◉ (?d) is assumed for
//│    - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                      ^
//│   ◉ (?d * _) comes from
//│   ▲  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                   ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed for
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│       ◉ (?i -> _ -> ?i) comes from
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       │ 
//│       ◉ (_ -> _ -> ?b) comes from
//│          - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?j) is assumed for
//│   ▲  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?h * _) comes from
//│      - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^^^^^^^
//│ ◉ (?h) is assumed for
//│ ▲  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1359    let base = List.combine l1 l2 in
//│ │                                       ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?g) ---> (?c) ~~~> (?c * _ list) ---> (?e) ---> (?f) ---> (?a * _)  ~~~> (?a) ---> (?h) ~~~> (?h * _) ---> (?j) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?i -> _ -> ?i)  ~~~> (_ -> ?i)  ~~~> (?i) ---> (?d * _)  ~~~> (?d) ~~~> (?d * _) <--- (?i) <~~~ (_ -> ?i) <~~~  (?i -> _ -> ?i) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?j) <--- (?h * _)  <~~~ (?h) <--- (?a) <~~~ (?a * _) <--- (?f) <--- (_ list * _)  <~~~ (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?g) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?c * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?f) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ ▼ 
//│ ◉ (?h) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?h * _) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                    ^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│      - l.-1367  if diff < 0
//│                 ^^^^^^^^^^^
//│                 then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?b) comes from
//│       │  - l.-1360    let f a x = padZero l1 l2 in
//│       │                     ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) comes from
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│   ◉ (?i) is assumed for
//│   │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d * _) comes from
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                       ^^^^^^^
//│ ◉ (?d) is assumed for
//│    - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                      ^
//│   ◉ (?d * _) comes from
//│   ▲  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                   ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed for
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│       ◉ (?i -> _ -> ?i) comes from
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       │ 
//│       ◉ (_ -> _ -> ?b) comes from
//│          - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?j) is assumed for
//│   ▲  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?h * _) comes from
//│      - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^^^^^^^
//│ ◉ (?h) is assumed for
//│ ▲  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ │ 
//│ ◉ (?a) is assumed for
//│    - l.-1361  let add (l1,l2) =
//│                        ^^
//│   ◉ (?a * _) comes from
//│   ▲  - l.-1361  let add (l1,l2) =
//│   │                     ^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?f) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) comes from
//│      - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (_ list) comes from
//│    - l.-1366  then (((clone 0 (-1 * diff)) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                                          ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?g) ---> (?c) ~~~> (?c * _ list) ---> (?e) ---> (?f) ---> (?a * _)  ~~~> (?a) ---> (?h) ~~~> (?h * _) ---> (?j) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?i -> _ -> ?i)  ~~~> (_ -> ?i)  ~~~> (?i) ---> (?d * _)  ~~~> (?d) ~~~> (?d * _) <--- (?i) <~~~ (_ -> ?i) <~~~  (?i -> _ -> ?i) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  <~~~ (?b) <--- (?j) <--- (?h * _)  <~~~ (?h) <--- (?a) <~~~ (?a * _) <--- (?f) <--- (?e) <--- (?c * _ list)  <~~~ (?c) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.8      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ ▼ 
//│ ◉ (?g) is assumed for
//│ │  - l.-1362let bigAdd l1 l2 =
//│ │                      ^^
//│ │  - l.-1356  removeZero (add (padZero l1 l2));;
//│ │                                      ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?c * _ list) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?f) is assumed for
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?a * _) comes from
//│      - l.-1361  let add (l1,l2) =
//│                         ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-1361  let add (l1,l2) =
//│ │                      ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ ▼ 
//│ ◉ (?h) is assumed for
//│    - l.-1369let padZero l1 l2 =
//│                         ^^
//│   ◉ (?h * _) comes from
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                                                                    ^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?j) is assumed for
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│      - l.-1367  if diff < 0
//│                 ^^^^^^^^^^^
//│                 then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│       ◉ (_ -> _ -> ?b) comes from
//│       │  - l.-1360    let f a x = padZero l1 l2 in
//│       │                     ^^^^^^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       ▼ 
//│       ◉ (?i -> _ -> ?i) comes from
//│          - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                       ^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│   ◉ (?i) is assumed for
//│   │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d * _) comes from
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                       ^^^^^^^
//│ ◉ (?d) is assumed for
//│    - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                      ^
//│   ◉ (?d * _) comes from
//│   ▲  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│   │                   ^^^^^^^
//│   │ 
//│   ◉ (?i) is assumed for
//│      - l.-1357    let (_,res) = List.fold_left f base args in res in
//│                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?i) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                           ^^^^^^^^
//│       ◉ (?i -> _ -> ?i) comes from
//│       ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│       │                               ^^^^^^^^^^^^^^
//│       │  - l.-1357    let (_,res) = List.fold_left f base args in res in
//│       │                                            ^
//│       │ 
//│       ◉ (_ -> _ -> ?b) comes from
//│          - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?b) comes from
//│        - l.-1360    let f a x = padZero l1 l2 in
//│                             ^^^^^^^^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?j) is assumed for
//│   ▲  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?h * _) comes from
//│      - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^^^^^^^
//│ ◉ (?h) is assumed for
//│ ▲  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1360    let f a x = padZero l1 l2 in
//│ │                                   ^^
//│ │ 
//│ ◉ (?a) is assumed for
//│    - l.-1361  let add (l1,l2) =
//│                        ^^
//│   ◉ (?a * _) comes from
//│   ▲  - l.-1361  let add (l1,l2) =
//│   │                     ^^^^^^^
//│   │  - l.-1356  removeZero (add (padZero l1 l2));;
//│   │                             ^^^^^^^^^^^^^^^
//│   │  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?f) is assumed for
//│   ▲  - l.-1367  if diff < 0
//│   │             ^^^^^^^^^^^
//│   │             then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?e) is assumed for
//│   ▲  - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│   │                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?c * _ list) comes from
//│      - l.-1365  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.-1369let padZero l1 l2 =
//│ │                       ^^
//│ │  - l.-1368  let diff = (List.length l1) - (List.length l2) in
//│ │                                     ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ helper: int -> int
//│ tenEx: int -> list[int] -> list[int]
//│ bigMul: 'b -> list[int] -> list[int]
//│   where
//│     'b = list[int] -> list[('c, list['a],)], list['d]
//│ U max: 13, total: 318
//│ UERR 22 errors
//│ L: 3 [([α951'], [[[α809'']]],) ~ list[α884''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', [α907'' - ([[α907'']], [[α878'']],) ~ ([α879''], [α877''],) - α879'', L: 2 [([[α907'']], [[α878'']],) ~ ([α879''], [α877''],), ([[α907'']], [[α878'']],) <: α908'', α908'' <: α909'', [α909'' - (α912'' -> [α909'']) ~ (α913'' -> α910'') - α910'', L: 1 [(α912'' -> [α909'']) ~ (α913'' -> α910''), [(α912'' -> [α909'']) - (α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')) - (α913'' -> α910''), L: 0 [(α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')), (α911'' -> (α912'' -> [α909''])) <: (α910'' -> (α913'' -> α910''))]]]], α910'' <: ([α879''], [α877''],)]], [α879'' - ([α879''], [α877''],) ~ ([[α907'']], [[α878'']],) - α907'', L: 2 [([α879''], [α877''],) ~ ([[α907'']], [[α878'']],), ([α879''], [α877''],) :> α910'', [α910'' - (α913'' -> α910'') ~ (α912'' -> [α909'']) - α909'', L: 1 [(α913'' -> α910'') ~ (α912'' -> [α909'']), [(α913'' -> α910'') - (α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])) - (α912'' -> [α909'']), L: 0 [(α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])), (α910'' -> (α913'' -> α910'')) :> (α911'' -> (α912'' -> [α909'']))]]]], α909'' :> α908'', α908'' :> ([[α907'']], [[α878'']],)]], α907'' :> α840'', α840'' <: list[α884'']]
//│ L: 3 [([α951'], [[[α809'']]],) ~ list[α814''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', [α907'' - ([[α907'']], [[α878'']],) ~ ([α879''], [α877''],) - α879'', L: 2 [([[α907'']], [[α878'']],) ~ ([α879''], [α877''],), ([[α907'']], [[α878'']],) <: α908'', α908'' <: α909'', [α909'' - (α912'' -> [α909'']) ~ (α913'' -> α910'') - α910'', L: 1 [(α912'' -> [α909'']) ~ (α913'' -> α910''), [(α912'' -> [α909'']) - (α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')) - (α913'' -> α910''), L: 0 [(α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')), (α911'' -> (α912'' -> [α909''])) <: (α910'' -> (α913'' -> α910''))]]]], α910'' <: ([α879''], [α877''],)]], [α879'' - ([α879''], [α877''],) ~ ([[α907'']], [[α878'']],) - α907'', L: 2 [([α879''], [α877''],) ~ ([[α907'']], [[α878'']],), ([α879''], [α877''],) :> α910'', [α910'' - (α913'' -> α910'') ~ (α912'' -> [α909'']) - α909'', L: 1 [(α913'' -> α910'') ~ (α912'' -> [α909'']), [(α913'' -> α910'') - (α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])) - (α912'' -> [α909'']), L: 0 [(α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])), (α910'' -> (α913'' -> α910'')) :> (α911'' -> (α912'' -> [α909'']))]]]], α909'' :> α908'', α908'' :> ([[α907'']], [[α878'']],)]], α907'' :> α840'', [α840'' - ([α840''], [α880''],) ~ ([[α839'']], [[list[α841'']]],) - α839'', L: 0 [([α840''], [α880''],) ~ ([[α839'']], [[list[α841'']]],), ([α840''], [α880''],) :> α883'', α883'' :> α882'', α882'' :> ([[α839'']], [[list[α841'']]],)]], α839'' <: list[α814'']]
//│ L: 2 [([[int]], [[list['a1109']]],) ~ list['a982'], ([[int]], [[list['a1109']]],) <: α971', [α971' - (α972' -> α971') ~ (α976' -> α979') - α979', L: 1 [(α972' -> α971') ~ (α976' -> α979'), [(α972' -> α971') - (α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')) - (α976' -> α979'), L: 0 [(α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')), (α971' -> (α972' -> α971')) :> (α973' -> (α976' -> α979'))]]]], α979' :> α981', α981' :> α980', α980' :> list['a982']]
//│ L: 0 [([α951'], [[[α809'']]],) ~ list[α814''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', α839'' <: list[α814'']]
//│ L: 1 [([α951'], [[[α809'']]],) ~ list[α838''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', α907'' <: list[α838'']]
//│ L: 0 [(α938'' -> α876'') ~ list['a812''], (α938'' -> α876'') <: α810'', α810'' :> list['a812'']]
//│ L: 2 [([[int]], [[list['a1109']]],) ~ (α983' -> α993'), ([[int]], [[list['a1109']]],) <: α971', [α971' - (α972' -> α971') ~ (α976' -> α979') - α979', L: 1 [(α972' -> α971') ~ (α976' -> α979'), [(α972' -> α971') - (α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')) - (α976' -> α979'), L: 0 [(α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')), (α971' -> (α972' -> α971')) :> (α973' -> (α976' -> α979'))]]]], α979' :> α981', α981' :> α980', α980' :> (α983' -> α993')]
//│ L: 2 [list['a982'] ~ (α983' -> α993'), list['a982'] <: α980', α980' <: α981', α981' <: α979', [α979' - (α976' -> α979') ~ (α972' -> α971') - α971', L: 1 [(α976' -> α979') ~ (α972' -> α971'), [(α976' -> α979') - (α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')) - (α972' -> α971'), L: 0 [(α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')), (α973' -> (α976' -> α979')) <: (α971' -> (α972' -> α971'))]]]], [α971' - (α972' -> α971') ~ (α976' -> α979') - α979', L: 1 [(α972' -> α971') ~ (α976' -> α979'), [(α972' -> α971') - (α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')) - (α976' -> α979'), L: 0 [(α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')), (α971' -> (α972' -> α971')) :> (α973' -> (α976' -> α979'))]]]], α979' :> α981', α981' :> α980', α980' :> (α983' -> α993')]
//│ L: 1 [([α951'], [[[α809'']]],) ~ list[α814''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], [α840'' - ([α840''], [α880''],) ~ ([[α839'']], [[list[α841'']]],) - α839'', L: 0 [([α840''], [α880''],) ~ ([[α839'']], [[list[α841'']]],), ([α840''], [α880''],) :> α883'', α883'' :> α882'', α882'' :> ([[α839'']], [[list[α841'']]],)]], α839'' <: list[α814'']]
//│ L: 3 [([α951'], [[[α809'']]],) ~ list[α838''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', [α907'' - ([[α907'']], [[α878'']],) ~ ([α879''], [α877''],) - α879'', L: 2 [([[α907'']], [[α878'']],) ~ ([α879''], [α877''],), ([[α907'']], [[α878'']],) <: α908'', α908'' <: α909'', [α909'' - (α912'' -> [α909'']) ~ (α913'' -> α910'') - α910'', L: 1 [(α912'' -> [α909'']) ~ (α913'' -> α910''), [(α912'' -> [α909'']) - (α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')) - (α913'' -> α910''), L: 0 [(α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')), (α911'' -> (α912'' -> [α909''])) <: (α910'' -> (α913'' -> α910''))]]]], α910'' <: ([α879''], [α877''],)]], [α879'' - ([α879''], [α877''],) ~ ([[α907'']], [[α878'']],) - α907'', L: 2 [([α879''], [α877''],) ~ ([[α907'']], [[α878'']],), ([α879''], [α877''],) :> α910'', [α910'' - (α913'' -> α910'') ~ (α912'' -> [α909'']) - α909'', L: 1 [(α913'' -> α910'') ~ (α912'' -> [α909'']), [(α913'' -> α910'') - (α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])) - (α912'' -> [α909'']), L: 0 [(α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])), (α910'' -> (α913'' -> α910'')) :> (α911'' -> (α912'' -> [α909'']))]]]], α909'' :> α908'', α908'' :> ([[α907'']], [[α878'']],)]], α907'' <: list[α838'']]
//│ L: 3 [([α951'], [[[α809'']]],) ~ list[α815''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', [α907'' - ([[α907'']], [[α878'']],) ~ ([α879''], [α877''],) - α879'', L: 2 [([[α907'']], [[α878'']],) ~ ([α879''], [α877''],), ([[α907'']], [[α878'']],) <: α908'', α908'' <: α909'', [α909'' - (α912'' -> [α909'']) ~ (α913'' -> α910'') - α910'', L: 1 [(α912'' -> [α909'']) ~ (α913'' -> α910''), [(α912'' -> [α909'']) - (α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')) - (α913'' -> α910''), L: 0 [(α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')), (α911'' -> (α912'' -> [α909''])) <: (α910'' -> (α913'' -> α910''))]]]], α910'' <: ([α879''], [α877''],)]], [α879'' - ([α879''], [α877''],) ~ ([[α907'']], [[α878'']],) - α907'', L: 2 [([α879''], [α877''],) ~ ([[α907'']], [[α878'']],), ([α879''], [α877''],) :> α910'', [α910'' - (α913'' -> α910'') ~ (α912'' -> [α909'']) - α909'', L: 1 [(α913'' -> α910'') ~ (α912'' -> [α909'']), [(α913'' -> α910'') - (α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])) - (α912'' -> [α909'']), L: 0 [(α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])), (α910'' -> (α913'' -> α910'')) :> (α911'' -> (α912'' -> [α909'']))]]]], α909'' :> α908'', α908'' :> ([[α907'']], [[α878'']],)]], α907'' :> α840'', [α840'' - ([α840''], [α880''],) ~ ([[list[α815'']]], [[α866'']],) - list[α815''], L: 0 [([α840''], [α880''],) ~ ([[list[α815'']]], [[α866'']],), ([α840''], [α880''],) :> α883'', α883'' :> ([[list[α815'']]], [[α866'']],)]]]
//│ L: 2 [(α983' -> α993') ~ ([α1111'], [α1112'],), (α983' -> α993') <: α980', α980' <: α981', α981' <: α979', [α979' - (α976' -> α979') ~ (α972' -> α971') - α971', L: 1 [(α976' -> α979') ~ (α972' -> α971'), [(α976' -> α979') - (α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')) - (α972' -> α971'), L: 0 [(α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')), (α973' -> (α976' -> α979')) <: (α971' -> (α972' -> α971'))]]]], α971' <: ([α1111'], [α1112'],)]
//│ L: 2 [list['a982'] ~ ([α974'], [α975'],), list['a982'] <: α980', α980' <: α981', α981' <: α979', [α979' - (α976' -> α979') ~ (α972' -> α971') - α971', L: 1 [(α976' -> α979') ~ (α972' -> α971'), [(α976' -> α979') - (α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')) - (α972' -> α971'), L: 0 [(α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')), (α973' -> (α976' -> α979')) <: (α971' -> (α972' -> α971'))]]]], [α971' - (α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')) - α973', L: 0 [(α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')), (α971' -> (α972' -> α971')) :> (α973' -> (α976' -> α979'))]], α973' <: ([α974'], [α975'],)]
//│ L: 2 [(α983' -> α993') ~ ([α974'], [α975'],), (α983' -> α993') <: α980', α980' <: α981', α981' <: α979', [α979' - (α976' -> α979') ~ (α972' -> α971') - α971', L: 1 [(α976' -> α979') ~ (α972' -> α971'), [(α976' -> α979') - (α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')) - (α972' -> α971'), L: 0 [(α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')), (α973' -> (α976' -> α979')) <: (α971' -> (α972' -> α971'))]]]], [α971' - (α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')) - α973', L: 0 [(α971' -> (α972' -> α971')) ~ (α973' -> (α976' -> α979')), (α971' -> (α972' -> α971')) :> (α973' -> (α976' -> α979'))]], α973' <: ([α974'], [α975'],)]
//│ L: 2 [list[α943'] ~ (α969' -> α970'), list[α943'] :> α941', [α941' - (α941' -> α944') ~ ([α797'] -> α951') - α797', L: 1 [(α941' -> α944') ~ ([α797'] -> α951'), [(α941' -> α944') - (α940' -> (α941' -> α944')) ~ (['a811'] -> α950') - α950', L: 0 [(α940' -> (α941' -> α944')) ~ (['a811'] -> α950'), (α940' -> (α941' -> α944')) <: mulByDigit939', mulByDigit939' <: (['a811'] -> α950')]], α950' <: ([α797'] -> α951')]], α797' <: (α969' -> α970')]
//│ L: 3 [([α951'], [[[α809'']]],) ~ list[α881''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', [α907'' - ([[α907'']], [[α878'']],) ~ ([[list[α881'']]], [[α878'']],) - list[α881''], L: 2 [([[α907'']], [[α878'']],) ~ ([[list[α881'']]], [[α878'']],), ([[α907'']], [[α878'']],) <: α908'', α908'' <: α909'', [α909'' - (α912'' -> [α909'']) ~ (α913'' -> α910'') - α910'', L: 1 [(α912'' -> [α909'']) ~ (α913'' -> α910''), [(α912'' -> [α909'']) - (α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')) - (α913'' -> α910''), L: 0 [(α911'' -> (α912'' -> [α909''])) ~ (α910'' -> (α913'' -> α910'')), (α911'' -> (α912'' -> [α909''])) <: (α910'' -> (α913'' -> α910''))]]]], [α910'' - (α913'' -> α910'') ~ (α912'' -> [α909'']) - α909'', L: 1 [(α913'' -> α910'') ~ (α912'' -> [α909'']), [(α913'' -> α910'') - (α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])) - (α912'' -> [α909'']), L: 0 [(α910'' -> (α913'' -> α910'')) ~ (α911'' -> (α912'' -> [α909''])), (α910'' -> (α913'' -> α910'')) :> (α911'' -> (α912'' -> [α909'']))]]]], α909'' :> ([[list[α881'']]], [[α878'']],)]]]
//│ L: 1 [([α951'], [[[α809'']]],) ~ list[α884''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: list[α884'']]
//│ L: 0 [([α951'], [[[α809'']]],) ~ list[α815''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', α839'' <: list[α815'']]
//│ L: 1 [([α951'], [[[α809'']]],) ~ list[α815''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], [α840'' - ([α840''], [α880''],) ~ ([[list[α815'']]], [[α866'']],) - list[α815''], L: 0 [([α840''], [α880''],) ~ ([[list[α815'']]], [[α866'']],), ([α840''], [α880''],) :> α883'', α883'' :> ([[list[α815'']]], [[α866'']],)]]]
//│ L: 2 [list['a982'] ~ ([α1111'], [α1112'],), list['a982'] <: α980', α980' <: α981', α981' <: α979', [α979' - (α976' -> α979') ~ (α972' -> α971') - α971', L: 1 [(α976' -> α979') ~ (α972' -> α971'), [(α976' -> α979') - (α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')) - (α972' -> α971'), L: 0 [(α973' -> (α976' -> α979')) ~ (α971' -> (α972' -> α971')), (α973' -> (α976' -> α979')) <: (α971' -> (α972' -> α971'))]]]], α971' <: ([α1111'], [α1112'],)]
//│ L: 1 [([α951'], [[[α809'']]],) ~ list[α881''], ([α951'], [[[α809'']]],) <: α813'', α813'' <: α839'', [α839'' - ([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],) - α840'', L: 0 [([[α839'']], [[list[α841'']]],) ~ ([α840''], [α880''],), ([[α839'']], [[list[α841'']]],) <: α882'', α882'' <: α883'', α883'' <: ([α840''], [α880''],)]], α840'' <: α907'', [α907'' - ([[α907'']], [[α878'']],) ~ ([[list[α881'']]], [[α878'']],) - list[α881''], L: 0 [([[α907'']], [[α878'']],) ~ ([[list[α881'']]], [[α878'']],), ([[α907'']], [[α878'']],) <: α908'', α908'' <: α909'', α909'' :> ([[list[α881'']]], [[α878'']],)]]]
//│ L: 2 [list['a942'] ~ (α969' -> α970'), [list['a942'] - ([list['a942']] -> α948') ~ ([α797'] -> α951') - α797', L: 1 [([list['a942']] -> α948') ~ ([α797'] -> α951'), ([list['a942']] -> α948') :> α949', [α949' - ([α940'] -> α949') ~ (['a811'] -> α950') - α950', L: 0 [([α940'] -> α949') ~ (['a811'] -> α950'), ([α940'] -> α949') :> mulByDigit939', mulByDigit939' <: (['a811'] -> α950')]], α950' <: ([α797'] -> α951')]], α797' <: (α969' -> α970')]

// file 335
let fixpointHelper f =
  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
let rec wwhile (f,b) =
  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ [ERROR] Type `_ -> _` does not match `_ * bool`
//│ 
//│         (_ -> _) <--- (?c) <~~~ (?c * _) <~~~  ((?c * _) -> _) ---> (?wwhile) ---> ((?a * _) -> _)  <~~~ (?a * _)  <~~~ (?a) <--- (?b) <--- (_ * bool)
//│ 
//│ ◉ (_ -> _) comes from
//│ ▲  - l.4    match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ │                 ^
//│ │ 
//│ ◉ (?c) is assumed for
//│    - l.3  let rec wwhile (f,b) =
//│                           ^
//│   ◉ (?c * _) comes from
//│      - l.3  let rec wwhile (f,b) =
//│                            ^^^^^
//│     ◉ ((?c * _) -> _) comes from
//│     │  - l.3  let rec wwhile (f,b) =
//│     │                        ^^^^^^^
//│     │           match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│     │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.3  let rec wwhile (f,b) =
//│     │                 ^^^^^^
//│     ▼ 
//│     ◉ (?wwhile) is assumed for
//│     │  - l.3  let rec wwhile (f,b) =
//│     │                 ^^^^^^
//│     ▼ 
//│     ◉ ((?a * _) -> _) comes from
//│        - l.5  let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│                                    ^^^^^^
//│   ◉ (?a * _) comes from
//│      - l.5  let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│                                         ^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ ▲  - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ │                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│ │                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ * bool) comes from
//│    - l.2    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│                                                       ^^^^^^^^^^^
//│ fixpointHelper: ('a, bool,) -> ('a, bool,)
//│ wwhile: 'wwhile
//│   where
//│     'wwhile = ('a -> ('a, bool,), 'a,) -> 'b, ('a -> ('a, bool,), 'b,) -> 'b
//│ fixpoint: ('a, 'b,) -> 'b
//│ U max: 10, total: 58
//│ UERR 1 errors
//│ L: 2 [([α1143'] -> α1148') ~ ([[[α1151']]], [[bool]],), ([α1143'] -> α1148') :> α1142', [α1142' - ([α1142'], [α1143'],) ~ ([[α1153']], [[α1140']],) - α1153', L: 1 [([α1142'], [α1143'],) ~ ([[α1153']], [[α1140']],), [([α1142'], [α1143'],) - (([α1142'], [α1143'],) -> α1147') ~ (([[α1153']], [[α1140']],) -> α1155') - ([[α1153']], [[α1140']],), L: 0 [(([α1142'], [α1143'],) -> α1147') ~ (([[α1153']], [[α1140']],) -> α1155'), (([α1142'], [α1143'],) -> α1147') <: wwhile1141', wwhile1141' <: (([[α1153']], [[α1140']],) -> α1155')]]]], α1153' :> α1154', α1154' :> ([[[α1151']]], [[bool]],)]


// file 3 mod
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?b) <--- (?a) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.16       if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.16       if x = []
//│ │                  ^
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │  - l.19         (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.19         (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ~~~>  ((_ * _) list) ---> (?b list)  (?b) ~~~> (?b list) ---> (?c list)  ~~~> (?c) ~~~> (?c -> _) <~~~  (_ -> ?c -> _) <--- (_ -> ?d -> _)  <~~~ (?d -> _)  ~~~> (?d) ---> (?a) <--- (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                    ^^^^^^^
//│   ◉ ((_ * _) list) comes from
//│   │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│   │                                                  ^^^^^^^^^^^^^
//│   │  - l.25     let args = List.rev (List.combine l1 l2) in
//│   │                                 ^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b list) comes from
//│      - lib. let List.rev: 'a list -> 'a list
//│                           ^^^^^^^
//│ ◉ (?b) is assumed for
//│   ◉ (?b list) comes from
//│   │  - lib. let List.rev: 'a list -> 'a list
//│   │                                  ^^^^^^^
//│   │  - l.25     let args = List.rev (List.combine l1 l2) in
//│   │                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.26     let (_,res) = List.fold_left f base args in res in
//│   │                                                 ^^^^
//│   ▼ 
//│   ◉ (?c list) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                                            ^^^^^^^
//│ ◉ (?c) is assumed for
//│   ◉ (?c -> _) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (_ -> ?c -> _) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.26     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> ?d -> _) comes from
//│        - l.14     let f a x =
//│                         ^^^^^
//│                     let (carry,currentSum) = a in ...
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (?d -> _) comes from
//│      - l.14     let f a x =
//│                         ^^^
//│                   let (carry,currentSum) = a in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed for
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │  - l.16       if x = []
//│ │                  ^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.16       if x = []
//│ │                      ^^
//│ │ 
//│ ◉ (_ list) comes from
//│    - l.16       if x = []
//│                        ^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) <--- (?c) <~~~ (?c -> _) ~~~>  (_ -> ?c -> _) ---> (_ -> ?b -> _)  ~~~> (?b -> _)  <~~~ (?b) <~~~ (?b -> _) <~~~  (_ -> ?b -> _) <--- (_ -> ?c -> _)  <~~~ (?c -> _)  ~~~> (?c) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.16       if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.16       if x = []
//│ │                  ^
//│ │ 
//│ ◉ (?c) is assumed for
//│    - l.14     let f a x =
//│                       ^
//│   ◉ (?c -> _) comes from
//│      - l.14     let f a x =
//│                         ^^^
//│                   let (carry,currentSum) = a in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?c -> _) comes from
//│     │  - l.14     let f a x =
//│     │                   ^^^^^
//│     │               let (carry,currentSum) = a in ...
//│     │               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.26     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (_ -> ?b -> _) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (?b -> _) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?b) is assumed for
//│   ◉ (?b -> _) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (_ -> ?b -> _) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.26     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> ?c -> _) comes from
//│        - l.14     let f a x =
//│                         ^^^^^
//│                     let (carry,currentSum) = a in ...
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (?c -> _) comes from
//│      - l.14     let f a x =
//│                         ^^^
//│                   let (carry,currentSum) = a in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.14     let f a x =
//│ │                     ^
//│ │  - l.19         (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.19         (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: list[int] -> list[int] -> (list[int], list[int],)
//│ removeZero: list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ U max: 33, total: 532
//│ UERR 3 errors
//│ L: 2 [list['a1263''] ~ ([α1261''], [α1262''],), list['a1263''] <: α1264'', α1264'' :> α1260'', [α1260'' - (α1260'' -> α1257'') ~ (α1252'' -> α1251'') - α1252'', L: 1 [(α1260'' -> α1257'') ~ (α1252'' -> α1251''), [(α1260'' -> α1257'') - (α1253'' -> (α1260'' -> α1257'')) ~ (α1251'' -> (α1252'' -> α1251'')) - (α1252'' -> α1251''), L: 0 [(α1253'' -> (α1260'' -> α1257'')) ~ (α1251'' -> (α1252'' -> α1251'')), (α1253'' -> (α1260'' -> α1257'')) <: (α1251'' -> (α1252'' -> α1251''))]]]], [α1252'' - (α1252'' -> α1251'') ~ (α1260'' -> α1257'') - α1260'', L: 1 [(α1252'' -> α1251'') ~ (α1260'' -> α1257''), [(α1252'' -> α1251'') - (α1251'' -> (α1252'' -> α1251'')) ~ (α1253'' -> (α1260'' -> α1257'')) - (α1260'' -> α1257''), L: 0 [(α1251'' -> (α1252'' -> α1251'')) ~ (α1253'' -> (α1260'' -> α1257'')), (α1251'' -> (α1252'' -> α1251'')) :> (α1253'' -> (α1260'' -> α1257''))]]]], α1260'' <: ([α1261''], [α1262''],)]
//│ L: 2 [([α1249''], [α1250''],) ~ list['a1263''], [([α1249''], [α1250''],) - list[([α1249''], [α1250''],)] ~ list[α1266''] - α1266'', L: 0 [list[([α1249''], [α1250''],)] ~ list[α1266''], list[([α1249''], [α1250''],)] <: list[α1266'']]], [α1266'' - list[α1266''] ~ list[α1252''] - α1252'', L: 0 [list[α1266''] ~ list[α1252''], list[α1266''] <: list[α1252'']]], [α1252'' - (α1252'' -> α1251'') ~ (α1260'' -> α1257'') - α1260'', L: 1 [(α1252'' -> α1251'') ~ (α1260'' -> α1257''), [(α1252'' -> α1251'') - (α1251'' -> (α1252'' -> α1251'')) ~ (α1253'' -> (α1260'' -> α1257'')) - (α1260'' -> α1257''), L: 0 [(α1251'' -> (α1252'' -> α1251'')) ~ (α1253'' -> (α1260'' -> α1257'')), (α1251'' -> (α1252'' -> α1251'')) :> (α1253'' -> (α1260'' -> α1257''))]]]], α1260'' <: α1264'', α1264'' :> list['a1263'']]
//│ L: 0 [list['a1240'''] ~ ([α1244'''], [α1245'''],), list['a1240'''] <: α1239''', α1239''' :> α1235''', α1235''' <: ([α1244'''], [α1245'''],)]

// file 1935
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) comes from
//│ │  - l.15     let base = 0 in
//│ │                        ^
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                                            ^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.17     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) <--- (?b) <~~~ (?b -> _ -> int) ---> (?a -> _ -> ?a)  <~~~ (?a) ---> (_ * _)
//│ 
//│ ◉ (int) comes from
//│ ▲  - lib. let (+): int -> int -> int
//│ │                  ^^^
//│ │  - l.14     let f a x = (a + x) mod 10 in
//│ │                          ^
//│ │ 
//│ ◉ (?b) is assumed for
//│    - l.14     let f a x = (a + x) mod 10 in
//│                     ^
//│   ◉ (?b -> _ -> int) comes from
//│   │  - l.14     let f a x = (a + x) mod 10 in
//│   │                   ^^^^^^^^^^^^^^^^^^^^
//│   │  - l.17     let (_,res) = List.fold_left f base args in res in
//│   │                                          ^
//│   ▼ 
//│   ◉ (?a -> _ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                   ^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.17     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ~~~>  (_ -> int) ~~~>  (_ -> _ -> int) ---> (?a -> _ -> ?a)  ~~~> (_ -> ?a)  ~~~> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) comes from
//│    - l.14     let f a x = (a + x) mod 10 in
//│                           ^^^^^^^^^^^^^^
//│    - lib. let mod: int -> int -> int
//│                                  ^^^
//│   ◉ (_ -> int) comes from
//│      - l.14     let f a x = (a + x) mod 10 in
//│                         ^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> int) comes from
//│     │  - l.14     let f a x = (a + x) mod 10 in
//│     │                   ^^^^^^^^^^^^^^^^^^^^
//│     │  - l.17     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.17     let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.17     let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ padZero: list[int] -> list[int] -> (list[int], list[int],)
//│ removeZero: list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ U max: 63, total: 550
//│ UERR 3 errors
//│ L: 0 [int ~ ([α1427''], [α1428''],), int <: α1420'', α1420'' <: ([α1427''], [α1428''],)]
//│ L: 1 [int ~ ([α1427''], [α1428''],), int :> α1422'', [α1422'' - (α1422'' -> (α1423'' -> [int])) ~ (α1420'' -> (α1421'' -> α1420'')) - α1420'', L: 0 [(α1422'' -> (α1423'' -> [int])) ~ (α1420'' -> (α1421'' -> α1420'')), (α1422'' -> (α1423'' -> [int])) <: (α1420'' -> (α1421'' -> α1420''))]], α1420'' <: ([α1427''], [α1428''],)]
//│ L: 2 [int ~ ([α1427''], [α1428''],), [int - (α1423'' -> [int]) ~ (α1421'' -> α1420'') - α1420'', L: 1 [(α1423'' -> [int]) ~ (α1421'' -> α1420''), [(α1423'' -> [int]) - (α1422'' -> (α1423'' -> [int])) ~ (α1420'' -> (α1421'' -> α1420'')) - (α1421'' -> α1420''), L: 0 [(α1422'' -> (α1423'' -> [int])) ~ (α1420'' -> (α1421'' -> α1420'')), (α1422'' -> (α1423'' -> [int])) <: (α1420'' -> (α1421'' -> α1420''))]]]], α1420'' <: ([α1427''], [α1428''],)]



// file 1907
let intboolf f x = ((f x), ((f x) < 1));;
let fixpoint (f,b) = wwhile (intboolf, b);;
let rec wwhile (f,b) =
  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;
//│ [ERROR] Type `_ * _` does not match `_ -> (_ * bool)`
//│ 
//│         (_ * _) <--- (?a) <~~~ (_ -> ?a) <--- (?b) <~~~ (?b * _) <~~~  ((?b * _) -> _) ---> (?wwhile) ---> ((_ -> _ -> (_ * bool) * _) -> _)  <~~~ (_ -> _ -> (_ * bool) * _)  <~~~ (_ -> _ -> (_ * bool))  <~~~ (_ -> (_ * bool))
//│ 
//│ ◉ (_ * _) comes from
//│ ▲  - l.-351  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│ │                             ^^^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed for
//│    - l.-351  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│                    ^^^
//│   ◉ (_ -> ?a) comes from
//│   ▲  - l.-351  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│   │                  ^
//│   │ 
//│   ◉ (?b) is assumed for
//│      - l.-352let rec wwhile (f,b) =
//│                              ^
//│     ◉ (?b * _) comes from
//│        - l.-352let rec wwhile (f,b) =
//│                               ^^^^^
//│       ◉ ((?b * _) -> _) comes from
//│       │  - l.-352let rec wwhile (f,b) =
//│       │                         ^^^^^^^
//│       │            match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│       │            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│       │  - l.-352let rec wwhile (f,b) =
//│       │                  ^^^^^^
//│       ▼ 
//│       ◉ (?wwhile) is assumed for
//│       │  - l.-352let rec wwhile (f,b) =
//│       │                  ^^^^^^
//│       ▼ 
//│       ◉ ((_ -> _ -> (_ * bool) * _) -> _) comes from
//│          - l.2  let fixpoint (f,b) = wwhile (intboolf, b);;
//│                                      ^^^^^^
//│     ◉ (_ -> _ -> (_ * bool) * _) comes from
//│        - l.2  let fixpoint (f,b) = wwhile (intboolf, b);;
//│                                           ^^^^^^^^^^^^^
//│   ◉ (_ -> _ -> (_ * bool)) comes from
//│      - l.2  let fixpoint (f,b) = wwhile (intboolf, b);;
//│                                          ^^^^^^^^
//│      - l.1  let intboolf f x = ((f x), ((f x) < 1));;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (_ -> (_ * bool)) comes from
//│    - l.1  let intboolf f x = ((f x), ((f x) < 1));;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^
//│ intboolf: ('a -> int) -> 'a -> (int, bool,)
//│ fixpoint: ('a, 'b,) -> 'b
//│ wwhile: 'wwhile
//│   where
//│     'wwhile = ('a -> ('a, bool,), 'a,) -> 'b, ('a -> ('a, bool,), 'b,) -> 'b
//│ U max: 10, total: 70
//│ UERR 1 errors
//│ L: 3 [([α1505'], [α1510'],) ~ (α1512' -> ([α1515'], [[bool]],)), ([α1505'], [α1510'],) :> α1509', [α1509' - ([α1504'] -> α1509') ~ (α1511' -> (α1512' -> ([α1515'], [[bool]],))) - (α1512' -> ([α1515'], [[bool]],)), L: 2 [([α1504'] -> α1509') ~ (α1511' -> (α1512' -> ([α1515'], [[bool]],))), ([α1504'] -> α1509') :> α1503', [α1503' - ([α1503'], [α1504'],) ~ ([[(α1511' -> (α1512' -> ([α1515'], [[bool]],)))]], [[α1501']],) - (α1511' -> (α1512' -> ([α1515'], [[bool]],))), L: 1 [([α1503'], [α1504'],) ~ ([[(α1511' -> (α1512' -> ([α1515'], [[bool]],)))]], [[α1501']],), [([α1503'], [α1504'],) - (([α1503'], [α1504'],) -> α1508') ~ (([[(α1511' -> (α1512' -> ([α1515'], [[bool]],)))]], [[α1501']],) -> α1516') - ([[(α1511' -> (α1512' -> ([α1515'], [[bool]],)))]], [[α1501']],), L: 0 [(([α1503'], [α1504'],) -> α1508') ~ (([[(α1511' -> (α1512' -> ([α1515'], [[bool]],)))]], [[α1501']],) -> α1516'), (([α1503'], [α1504'],) -> α1508') <: wwhile1502', wwhile1502' <: (([[(α1511' -> (α1512' -> ([α1515'], [[bool]],)))]], [[α1501']],) -> α1516')]]]]]]]



// file 2047
let identity a = a;;
let pipe fs =
  let f a x = a x in let base = identity in List.fold_left f base fs;;
//│ identity: 'a -> 'a
//│ pipe: list['a] -> 'b
//│   where
//│     'b = 'b -> 'b, ('c -> 'c) -> 'c -> 'c
//│     'a = 'a -> 'a, ('c -> 'c) -> 'c -> 'c
//│     'c = 'c -> 'c



// file 830
let modulus ss = ss mod 10;;
let rec digitsOfInt n =
  if n <= 0
  then []
  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;
let lt10 q = q < 10;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
let rec additivePersistence n =
  if lt10 n
  then n
  else
    (match n with
     | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ [ERROR] Type `int` does not match `_ -> _`
//│ 
//│         (int) ---> (?b) ~~~> (_ -> ?b) ---> (?sumList) ---> (_ list -> ?c)  ~~~> (?c) ~~~> (_ list -> ?c) <--- (?sumList) <--- (_ -> ?b)  <~~~ (?b) <~~~ (_ -> ?b) ---> (?sumList) ---> (_ -> ?a)  ~~~> (?a) ---> (_ -> _)
//│ 
//│ ◉ (int) comes from
//│ │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│ │                                                    ^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (?sumList) is assumed for
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (_ list -> ?c) comes from
//│      - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│                                                                         ^^^^^^^
//│ ◉ (?c) is assumed for
//│    - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│                                                                      ^^^^^^^^^^^
//│   ◉ (_ list -> ?c) comes from
//│   ▲  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                                                                     ^^^^^^^
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   │ 
//│   ◉ (?sumList) is assumed for
//│   ▲  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   │ 
//│   ◉ (_ -> ?b) comes from
//│      - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│    - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (?sumList) is assumed for
//│   │  - l.7  let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
//│   │                 ^^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?a) comes from
//│      - l.13      | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│                                                   ^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.13      | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ │                                               ^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.13      | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│                                                 ^^^^^^^^^^
//│ modulus: int -> int
//│ digitsOfInt: int -> list[int]
//│ lt10: int -> bool
//│ sumList: list[int] -> int
//│ additivePersistence: int -> int
//│ U max: 9, total: 137
//│ UERR 1 errors
//│ L: 1 [int ~ ([additivePersistence1569'] -> α1601'), int <: α1588', [α1588' - (α1586' -> α1588') ~ ([list['a1587']] -> α1589') - α1589', L: 0 [(α1586' -> α1588') ~ ([list['a1587']] -> α1589'), (α1586' -> α1588') <: sumList1585', sumList1585' <: ([list['a1587']] -> α1589')]], [α1589' - ([list['a1587']] -> α1589') ~ (α1586' -> α1588') - α1588', L: 0 [([list['a1587']] -> α1589') ~ (α1586' -> α1588'), ([list['a1587']] -> α1589') :> sumList1585', sumList1585' :> (α1586' -> α1588')]], [α1588' - (α1586' -> α1588') ~ ([α1590'] -> α1600') - α1600', L: 0 [(α1586' -> α1588') ~ ([α1590'] -> α1600'), (α1586' -> α1588') <: sumList1585', sumList1585' <: ([α1590'] -> α1600')]], α1600' <: ([additivePersistence1569'] -> α1601')]



// file 1770
let rec filter l a =
  match l with
  | [] -> []
  | h::t -> if a = h then filter t a else h :: (filter t a);;
let removeDuplicates l =
  let rec helper (seen,rest) =
    match rest with
    | [] -> seen
    | h::t ->
        let seen' = h in
        let rest' = h :: (filter (t h)) in helper (seen', rest') in
  List.rev (helper ([], l));;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ │                                           ^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                             ^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) ~~~>  (_ -> _ -> _) ---> (?filter) ---> (_ -> ?a)  ~~~> (?a) ---> (_ list)
//│ 
//│ ◉ (_ -> _) comes from
//│    - l.1  let rec filter l a =
//│                            ^^^
//│             match l with ...
//│             ^^^^^^^^^^^^^^^^
//│   ◉ (_ -> _ -> _) comes from
//│   │  - l.1  let rec filter l a =
//│   │                        ^^^^^
//│   │           match l with ...
//│   │           ^^^^^^^^^^^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (?filter) is assumed for
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?a) comes from
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                       ^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ │                                  ^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                               ^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) <--- (?a) <~~~ (_ list -> ?a) <--- (?filter) ---> (_ list -> ?b)  ~~~> (?b) <~~~ (_ list -> ?b) <--- (?filter) ---> (_ -> ?c)  ~~~> (?c) ---> (_ list)
//│ 
//│ ◉ (_ -> _) comes from
//│ ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ │                                   ^^^^^^^^
//│ │ 
//│ ◉ (?a) is assumed for
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                     ^^^^^^^^
//│   ◉ (_ list -> ?a) comes from
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                   ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed for
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ list -> ?b) comes from
//│      - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                             ^^^^^^
//│ ◉ (?b) is assumed for
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                           ^^^^^^^^
//│   ◉ (_ list -> ?b) comes from
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                                         ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed for
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?c) comes from
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                       ^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ │                                  ^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                               ^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) <--- (?b) <~~~ (_ list -> ?b) <--- (?filter) ---> (_ list -> ?a)  ~~~> (?a) <~~~ (_ list -> ?a) <--- (?filter) ---> (_ list -> ?b)  ~~~> (?b) <~~~ (_ list -> ?b) <--- (?filter) ---> (_ -> ?c)  ~~~> (?c) ---> (_ list)
//│ 
//│ ◉ (_ -> _) comes from
//│ ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│ │                                                         ^^^^^^^^
//│ │ 
//│ ◉ (?b) is assumed for
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                           ^^^^^^^^
//│   ◉ (_ list -> ?b) comes from
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                                         ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed for
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ list -> ?a) comes from
//│      - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                       ^^^^^^
//│ ◉ (?a) is assumed for
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                     ^^^^^^^^
//│   ◉ (_ list -> ?a) comes from
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                   ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed for
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ list -> ?b) comes from
//│      - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                             ^^^^^^
//│ ◉ (?b) is assumed for
//│    - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│                                                           ^^^^^^^^
//│   ◉ (_ list -> ?b) comes from
//│   ▲  - l.4    | h::t -> if a = h then filter t a else h :: (filter t a);;
//│   │                                                         ^^^^^^
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   │ 
//│   ◉ (?filter) is assumed for
//│   │  - l.1  let rec filter l a =
//│   │                 ^^^^^^
//│   ▼ 
//│   ◉ (_ -> ?c) comes from
//│      - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                       ^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│ │                                  ^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - l.11         let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                               ^^^^^^^^^^^^^^^^^^^
//│ filter: list['a] -> 'b -> 'c
//│   where
//│     'c = list['a], list['b]
//│ removeDuplicates: list[list['a]] -> list['a]
//│ U max: 11, total: 181
//│ UERR 4 errors
//│ L: 1 [([α1632'''] -> α1634''') ~ list[['a1626'']], ([α1632'''] -> α1634''') :> α1638''', [α1638''' - ([list['a1630''']] -> α1638''') ~ ([list['a1630''']] -> α1636''') - α1636''', L: 0 [([list['a1630''']] -> α1638''') ~ ([list['a1630''']] -> α1636'''), ([list['a1630''']] -> α1638''') :> filter1628''', filter1628''' <: ([list['a1630''']] -> α1636''')]], [α1636''' - ([list['a1630''']] -> α1636''') ~ ([list['a1630''']] -> α1638''') - α1638''', L: 0 [([list['a1630''']] -> α1636''') ~ ([list['a1630''']] -> α1638'''), ([list['a1630''']] -> α1636''') :> filter1628''', filter1628''' <: ([list['a1630''']] -> α1638''')]], [α1638''' - ([list['a1630''']] -> α1638''') ~ (α1641''' -> α1642''') - α1642''', L: 0 [([list['a1630''']] -> α1638''') ~ (α1641''' -> α1642'''), ([list['a1630''']] -> α1638''') :> filter1628''', filter1628''' <: (α1641''' -> α1642''')]], α1642''' <: list[['a1626'']]]
//│ L: 0 [list['a1626''] ~ (['a1626''] -> α1641'''), list['a1626''] <: (['a1626''] -> α1641''')]
//│ L: 1 [(α1632''' -> α1637''') ~ list[['a1626'']], [(α1632''' -> α1637''') - (α1629''' -> (α1632''' -> α1637''')) ~ (α1641''' -> α1642''') - α1642''', L: 0 [(α1629''' -> (α1632''' -> α1637''')) ~ (α1641''' -> α1642'''), (α1629''' -> (α1632''' -> α1637''')) <: filter1628''', filter1628''' <: (α1641''' -> α1642''')]], α1642''' <: list[['a1626'']]]
//│ L: 1 [([α1632'''] -> α1635''') ~ list[['a1626'']], ([α1632'''] -> α1635''') :> α1636''', [α1636''' - ([list['a1630''']] -> α1636''') ~ ([list['a1630''']] -> α1638''') - α1638''', L: 0 [([list['a1630''']] -> α1636''') ~ ([list['a1630''']] -> α1638'''), ([list['a1630''']] -> α1636''') :> filter1628''', filter1628''' <: ([list['a1630''']] -> α1638''')]], [α1638''' - ([list['a1630''']] -> α1638''') ~ (α1641''' -> α1642''') - α1642''', L: 0 [([list['a1630''']] -> α1638''') ~ (α1641''' -> α1642'''), ([list['a1630''']] -> α1638''') :> filter1628''', filter1628''' <: (α1641''' -> α1642''')]], α1642''' <: list[['a1626'']]]


// file 0221
let fu x b = (x, (b < (x b)));;
let rec wwhile (f,b) =
  let temp = f b in
  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
let fixpoint (f,b) = wwhile ((fu f), b);;
//│ fu: ('a -> 'b) -> 'a -> ('a -> 'b, bool,)
//│ wwhile: 'wwhile
//│   where
//│     'wwhile = ('a -> ('a, bool,), 'a,) -> 'b, ('a -> ('a, bool,), 'b,) -> 'b
//│ fixpoint: ('a, 'b,) -> 'b

// file 2338
:unify
let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│ [ERROR] Type `_ * _ * _` does not match `_ -> _`
//│ 
//│         (?a * _ * _) <~~~  ((?a * _ * _) -> ?b) ---> (?assoc) ---> (?a -> ?c)  <~~~ (?a) ---> (?b) ~~~> ((?a * _ * _) -> ?b) ---> (?assoc) ---> (?a -> ?c)  ~~~> (?c) ---> (_ -> _)
//│ 
//│ ◉ (?a * _ * _) comes from
//│    - l.1  let rec assoc (d,k,l) =
//│                         ^^^^^^^
//│   ◉ ((?a * _ * _) -> ?b) comes from
//│   │  - l.1  let rec assoc (d,k,l) =
//│   │                       ^^^^^^^^^
//│   │           match l with ...
//│   │           ^^^^^^^^^^^^^^^^
//│   │  - l.1  let rec assoc (d,k,l) =
//│   │                 ^^^^^
//│   ▼ 
//│   ◉ (?assoc) is assumed for
//│   │  - l.1  let rec assoc (d,k,l) =
//│   │                 ^^^^^
//│   ▼ 
//│   ◉ (?a -> ?c) comes from
//│      - l.4    | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│                                                                 ^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.1  let rec assoc (d,k,l) =
//│ │                        ^
//│ │  - l.3    | [] -> d
//│ │                   ^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.2    match l with
//│             ^^^^^^^^^^^^
//│             | [] -> d ...
//│             ^^^^^^^^^^^^^
//│   ◉ ((?a * _ * _) -> ?b) comes from
//│   │  - l.1  let rec assoc (d,k,l) =
//│   │                       ^^^^^^^^^
//│   │           match l with ...
//│   │           ^^^^^^^^^^^^^^^^
//│   │  - l.1  let rec assoc (d,k,l) =
//│   │                 ^^^^^
//│   ▼ 
//│   ◉ (?assoc) is assumed for
//│   │  - l.1  let rec assoc (d,k,l) =
//│   │                 ^^^^^
//│   ▼ 
//│   ◉ (?a -> ?c) comes from
//│      - l.4    | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│                                                                 ^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.4    | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│ │                                                             ^^^^^^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.4    | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│                                                               ^^^^^^^
//│ assoc: 'assoc
//│   where
//│     'assoc = (('b, 'c, list[('d, 'a -> ('b, 'c, 'e,),)],), 'c, list[('d, 'a -> ('b, 'c, 'e,),)],) -> ('b, 'c, 'e,), ('b, 'c, list[('d, 'a -> ('b, 'c, 'e,),)],) -> ('b, 'c, 'e,)
//│     'b = ('b, 'c, list[('d, 'a -> ('b, 'c, 'e,),)],)
//│     'a = ('d, 'a -> ('b, 'c, 'e,),)
//│     'e = list[('d, 'a -> ('b, 'c, 'e,),)]
//│ U max: 10, total: 35
//│ UERR 1 errors
//│ L: 1 [([α1696'], [α1697'], [α1698'],) ~ ([α1697'] -> α1708'), [([α1696'], [α1697'], [α1698'],) - (([α1696'], [α1697'], [α1698'],) -> α1699') ~ ([α1696'] -> α1707') - α1696', L: 0 [(([α1696'], [α1697'], [α1698'],) -> α1699') ~ ([α1696'] -> α1707'), (([α1696'], [α1697'], [α1698'],) -> α1699') <: assoc1695', assoc1695' <: ([α1696'] -> α1707')]], α1696' <: α1699', [α1699' - (([α1696'], [α1697'], [α1698'],) -> α1699') ~ ([α1696'] -> α1707') - α1707', L: 0 [(([α1696'], [α1697'], [α1698'],) -> α1699') ~ ([α1696'] -> α1707'), (([α1696'], [α1697'], [α1698'],) -> α1699') <: assoc1695', assoc1695' <: ([α1696'] -> α1707')]], α1707' <: ([α1697'] -> α1708')]
