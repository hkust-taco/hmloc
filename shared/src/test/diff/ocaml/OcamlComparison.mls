////////// file 1935

////////// ocamlc error
//
// File "1935.ml", line 22, characters 18-44:
// 22 |     let (_,res) = List.fold_left f base args in res in
//                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type int but an expression was expected of type
//          'a * 'b

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ padZero: list[int] -> list[int] -> (list[int], list[int],)
//│ removeZero: list[int] -> list[int]


let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ---> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) comes from
//│ │  - l.4      let base = 0 in
//│ │                        ^
//│ │  - l.6      let (_,res) = List.fold_left f base args in res in
//│ │                                            ^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.6      let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.6      let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) <--- (?b) ~~~> (?b -> _ -> int) ---> (?a -> _ -> ?a)  ~~~> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) comes from
//│ ▲  - lib. let (+): int -> int -> int
//│ │                  ^^^
//│ │  - l.3      let f a x = (a + x) mod 10 in
//│ │                          ^
//│ │ 
//│ ◉ (?b) is assumed for
//│    - l.3      let f a x = (a + x) mod 10 in
//│                     ^
//│   ◉ (?b -> _ -> int) comes from
//│   │  - l.3      let f a x = (a + x) mod 10 in
//│   │                   ^^^^^^^^^^^^^^^^^^^^
//│   │  - l.6      let (_,res) = List.fold_left f base args in res in
//│   │                                          ^
//│   ▼ 
//│   ◉ (?a -> _ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                   ^^^^^^^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.6      let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.6      let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ [ERROR] Type `int` does not match `_ * _`
//│ 
//│         (int) ~~~>  (_ -> int) ~~~>  (_ -> _ -> int) ---> (?a -> _ -> ?a)  <~~~ (_ -> ?a)  ~~~> (?a) ---> (_ * _)
//│ 
//│ ◉ (int) comes from
//│    - l.3      let f a x = (a + x) mod 10 in
//│                           ^^^^^^^^^^^^^^
//│    - lib. let mod: int -> int -> int
//│                                  ^^^
//│   ◉ (_ -> int) comes from
//│      - l.3      let f a x = (a + x) mod 10 in
//│                         ^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> int) comes from
//│     │  - l.3      let f a x = (a + x) mod 10 in
//│     │                   ^^^^^^^^^^^^^^^^^^^^
//│     │  - l.6      let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.6      let (_,res) = List.fold_left f base args in res in
//│ │                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.6      let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ U max: 63, total: 255
//│ UERR 3 errors
//│ L: 2 [int ~ ([α127''], [α128''],), [int - (α123'' -> [int]) ~ (α121'' -> α120'') - α120'', L: 1 [(α123'' -> [int]) ~ (α121'' -> α120''), [(α123'' -> [int]) - (α122'' -> (α123'' -> [int])) ~ (α120'' -> (α121'' -> α120'')) - (α121'' -> α120''), L: 0 [(α122'' -> (α123'' -> [int])) ~ (α120'' -> (α121'' -> α120'')), (α122'' -> (α123'' -> [int])) <: (α120'' -> (α121'' -> α120''))]]]], α120'' <: ([α127''], [α128''],)]
//│ L: 1 [int ~ ([α127''], [α128''],), int :> α122'', [α122'' - (α122'' -> (α123'' -> [int])) ~ (α120'' -> (α121'' -> α120'')) - α120'', L: 0 [(α122'' -> (α123'' -> [int])) ~ (α120'' -> (α121'' -> α120'')), (α122'' -> (α123'' -> [int])) <: (α120'' -> (α121'' -> α120''))]], α120'' <: ([α127''], [α128''],)]
//│ L: 0 [int ~ ([α127''], [α128''],), int <: α120'', α120'' <: ([α127''], [α128''],)]

////////// file 0003

////////// ocamlc error
//
// File "0003.ml", line 23, characters 31-32:
// 23 |         (let (toSum1,toSum2) = x in
//                                     ^
// Error: This expression has type 'a list
//        but an expression was expected of type 'b * 'c

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ clone: 'a -> int -> list['a]
//│ padZero: list[int] -> list[int] -> (list[int], list[int],)
//│ removeZero: list[int] -> list[int]

:unify
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?b) <--- (?a) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.5        if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ ▲  - l.5        if x = []
//│ │                  ^
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │ 
//│ ◉ (?a) is assumed for
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │  - l.8          (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.8          (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ~~~>  ((_ * _) list) ---> (?b list)  (?b) <~~~ (?b list) ---> (?c list)  <~~~ (?c) <~~~ (?c -> _) ~~~>  (_ -> ?c -> _) <--- (_ -> ?d -> _)  <~~~ (?d -> _)  ~~~> (?d) ---> (?a) <--- (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                    ^^^^^^^
//│   ◉ ((_ * _) list) comes from
//│   │  - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│   │                                                  ^^^^^^^^^^^^^
//│   │  - l.14     let args = List.rev (List.combine l1 l2) in
//│   │                                 ^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b list) comes from
//│      - lib. let List.rev: 'a list -> 'a list
//│                           ^^^^^^^
//│ ◉ (?b) is assumed for
//│   ◉ (?b list) comes from
//│   │  - lib. let List.rev: 'a list -> 'a list
//│   │                                  ^^^^^^^
//│   │  - l.14     let args = List.rev (List.combine l1 l2) in
//│   │                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.15     let (_,res) = List.fold_left f base args in res in
//│   │                                                 ^^^^
//│   ▼ 
//│   ◉ (?c list) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                                            ^^^^^^^
//│ ◉ (?c) is assumed for
//│   ◉ (?c -> _) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (_ -> ?c -> _) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.15     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> ?d -> _) comes from
//│        - l.3      let f a x =
//│                         ^^^^^
//│                     let (carry,currentSum) = a in ...
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (?d -> _) comes from
//│      - l.3      let f a x =
//│                         ^^^
//│                   let (carry,currentSum) = a in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?d) is assumed for
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │  - l.5        if x = []
//│ │                  ^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.5        if x = []
//│ │                      ^^
//│ │ 
//│ ◉ (_ list) comes from
//│    - l.5        if x = []
//│                        ^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?a) <--- (?c) ~~~> (?c -> _) ~~~>  (_ -> ?c -> _) ---> (_ -> ?b -> _)  <~~~ (?b -> _)  <~~~ (?b) <~~~ (?b -> _) ~~~>  (_ -> ?b -> _) <--- (_ -> ?c -> _)  <~~~ (?c -> _)  ~~~> (?c) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.5        if x = []
//│ │                      ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.5        if x = []
//│ │                  ^
//│ │ 
//│ ◉ (?c) is assumed for
//│    - l.3      let f a x =
//│                       ^
//│   ◉ (?c -> _) comes from
//│      - l.3      let f a x =
//│                         ^^^
//│                   let (carry,currentSum) = a in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?c -> _) comes from
//│     │  - l.3      let f a x =
//│     │                   ^^^^^
//│     │               let (carry,currentSum) = a in ...
//│     │               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.15     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     ▼ 
//│     ◉ (_ -> ?b -> _) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (?b -> _) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?b) is assumed for
//│   ◉ (?b -> _) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (_ -> ?b -> _) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.15     let (_,res) = List.fold_left f base args in res in
//│     │                                          ^
//│     │ 
//│     ◉ (_ -> ?c -> _) comes from
//│        - l.3      let f a x =
//│                         ^^^^^
//│                     let (carry,currentSum) = a in ...
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (?c -> _) comes from
//│      - l.3      let f a x =
//│                         ^^^
//│                   let (carry,currentSum) = a in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.3      let f a x =
//│ │                     ^
//│ │  - l.8          (let (toSum1,toSum2) = x in
//│ │                                        ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.8          (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ U max: 35, total: 378
//│ UERR 3 errors
//│ L: 0 [list['a267'''] ~ ([α271'''], [α272'''],), list['a267'''] <: α266''', α266''' :> α262''', α262''' <: ([α271'''], [α272'''],)]
//│ L: 2 [list['a288''] ~ ([α286''], [α287''],), list['a288''] <: α289'', α289'' :> α285'', [α285'' - (α285'' -> α290'') ~ (α279'' -> α278'') - α279'', L: 1 [(α285'' -> α290'') ~ (α279'' -> α278''), [(α285'' -> α290'') - (α280'' -> (α285'' -> α290'')) ~ (α278'' -> (α279'' -> α278'')) - (α279'' -> α278''), L: 0 [(α280'' -> (α285'' -> α290'')) ~ (α278'' -> (α279'' -> α278'')), (α280'' -> (α285'' -> α290'')) <: (α278'' -> (α279'' -> α278''))]]]], [α279'' - (α279'' -> α278'') ~ (α285'' -> α290'') - α285'', L: 1 [(α279'' -> α278'') ~ (α285'' -> α290''), [(α279'' -> α278'') - (α278'' -> (α279'' -> α278'')) ~ (α280'' -> (α285'' -> α290'')) - (α285'' -> α290''), L: 0 [(α278'' -> (α279'' -> α278'')) ~ (α280'' -> (α285'' -> α290'')), (α278'' -> (α279'' -> α278'')) :> (α280'' -> (α285'' -> α290''))]]]], α285'' <: ([α286''], [α287''],)]
//│ L: 2 [([α276''], [α277''],) ~ list['a288''], [([α276''], [α277''],) - list[([α276''], [α277''],)] ~ list[α294''] - α294'', L: 0 [list[([α276''], [α277''],)] ~ list[α294''], list[([α276''], [α277''],)] <: list[α294'']]], [α294'' - list[α294''] ~ list[α279''] - α279'', L: 0 [list[α294''] ~ list[α279''], list[α294''] <: list[α279'']]], [α279'' - (α279'' -> α278'') ~ (α285'' -> α290'') - α285'', L: 1 [(α279'' -> α278'') ~ (α285'' -> α290''), [(α279'' -> α278'') - (α278'' -> (α279'' -> α278'')) ~ (α280'' -> (α285'' -> α290'')) - (α285'' -> α290''), L: 0 [(α278'' -> (α279'' -> α278'')) ~ (α280'' -> (α285'' -> α290'')), (α278'' -> (α279'' -> α278'')) :> (α280'' -> (α285'' -> α290''))]]]], α285'' <: α289'', α289'' :> list['a288'']]

////////// file 1948

////////// ocamlc error
//
// File "1948.ml", line 43, characters 46-70:
// 43 |     match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//                                                    ^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type 'a * 'b
//        but an expression was expected of type int list

let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (x1,x2) = x in
      let (carry,res) = a in
      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (carry,res) = List.fold_left f base args in [carry] @ res in
  removeZero (add (padZero l1 l2));;
let rec mulByDigit i l =
  let f a x =
    let carry = i * x in
    match a with
    | h::t -> ((h + carry) / 10) :: (mod (h + carry) 10) :: t
    | _ -> [carry / 10; mod carry 10] in
  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ helper: int -> int
//│ clone: 'a -> int -> list['a]
//│ padZero: list[int] -> list[int] -> (list[int], list[int],)
//│ removeZero: list[int] -> list[int]
//│ tenEx: int -> list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ mulByDigit: int -> list['a] -> list[int]


:unify
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│ 
//│         (_ -> _) ---> (?a) <--- (_ list)
//│ 
//│ ◉ (_ -> _) comes from
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) comes from
//│    - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-36  if (List.length l1) > (List.length l2)
//│ │                           ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ │                                                                      ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ │                                                              ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-35  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ │                                             ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?b) ---> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-33    if (List.length l1) < (List.length l2)
//│ │                             ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?c) ---> (?a) ~~~> (?a * _) ---> (?b) ---> (?d) ---> (?e * _)  ~~~> (?e) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.-37let padZero l1 l2 =
//│                       ^^
//│   ◉ (?a * _) comes from
//│   │  - l.-31    else (l1, l2);;
//│   │                  ^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) comes from
//│      - l.-25  let add (l1,l2) =
//│                       ^^^^^^^
//│ ◉ (?e) is assumed for
//│ │  - l.-25  let add (l1,l2) =
//│ │                    ^^
//│ │  - l.-19    let args = List.rev (List.combine l1 l2) in
//│ │                                               ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?c) ---> (?a) ~~~> (?a * _) ---> (?b) ---> (?d) ---> (?e * _)  <~~~ (?e) <~~~ (?e * _) <--- (?d) <--- (?b) <--- (_ list * _)  <~~~ (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.-37let padZero l1 l2 =
//│                       ^^
//│   ◉ (?a * _) comes from
//│   │  - l.-31    else (l1, l2);;
//│   │                  ^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) comes from
//│      - l.-25  let add (l1,l2) =
//│                       ^^^^^^^
//│ ◉ (?e) is assumed for
//│    - l.-25  let add (l1,l2) =
//│                      ^^
//│   ◉ (?e * _) comes from
//│   ▲  - l.-25  let add (l1,l2) =
//│   │                   ^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed for
//│   ▲  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (_ list * _) comes from
//│      - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (_ list) comes from
//│    - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│    - lib. let (@): 'a list -> 'a list -> 'a list
//│                                          ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?c) ---> (?a) ~~~> (?a * _) ---> (?b) ---> (?d) ---> (?e * _)  <~~~ (?e) <~~~ (?e * _) <--- (?d) <--- (?b) <--- (?a * _)  ~~~> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.-37let padZero l1 l2 =
//│                       ^^
//│   ◉ (?a * _) comes from
//│   │  - l.-31    else (l1, l2);;
//│   │                  ^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) comes from
//│      - l.-25  let add (l1,l2) =
//│                       ^^^^^^^
//│ ◉ (?e) is assumed for
//│    - l.-25  let add (l1,l2) =
//│                      ^^
//│   ◉ (?e * _) comes from
//│   ▲  - l.-25  let add (l1,l2) =
//│   │                   ^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed for
//│   ▲  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?a * _) comes from
//│      - l.-31    else (l1, l2);;
//│                      ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-36  if (List.length l1) > (List.length l2)
//│ │                           ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?c) ---> (?a) ~~~> (?a * _) ---> (?b) ---> (?d) ---> (?e * _)  <~~~ (?e) <~~~ (?e * _) <--- (?d) <--- (?b) <--- (?a * _)  ~~~> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.-37let padZero l1 l2 =
//│                       ^^
//│   ◉ (?a * _) comes from
//│   │  - l.-31    else (l1, l2);;
//│   │                  ^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) comes from
//│      - l.-25  let add (l1,l2) =
//│                       ^^^^^^^
//│ ◉ (?e) is assumed for
//│    - l.-25  let add (l1,l2) =
//│                      ^^
//│   ◉ (?e * _) comes from
//│   ▲  - l.-25  let add (l1,l2) =
//│   │                   ^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed for
//│   ▲  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?a * _) comes from
//│      - l.-31    else (l1, l2);;
//│                      ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-32    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ │                                                              ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?c) ---> (?a) ~~~> (?a * _) ---> (?b) ---> (?d) ---> (?e * _)  <~~~ (?e) <~~~ (?e * _) <--- (?d) <--- (?b) <--- (?a * _)  ~~~> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.-37let padZero l1 l2 =
//│                       ^^
//│   ◉ (?a * _) comes from
//│   │  - l.-31    else (l1, l2);;
//│   │                  ^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) comes from
//│      - l.-25  let add (l1,l2) =
//│                       ^^^^^^^
//│ ◉ (?e) is assumed for
//│    - l.-25  let add (l1,l2) =
//│                      ^^
//│   ◉ (?e * _) comes from
//│   ▲  - l.-25  let add (l1,l2) =
//│   │                   ^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed for
//│   ▲  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?a * _) comes from
//│      - l.-31    else (l1, l2);;
//│                      ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-35  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ │                                             ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│ 
//│         (_ * _) ---> (?c) ---> (?a) ~~~> (?a * _) ---> (?b) ---> (?d) ---> (?e * _)  <~~~ (?e) <~~~ (?e * _) <--- (?d) <--- (?b) <--- (?a * _)  ~~~> (?a) ---> (_ list)
//│ 
//│ ◉ (_ * _) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                    ^^
//│ │  - l.-17  removeZero (add (padZero l1 l2));;
//│ │                                    ^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.-37let padZero l1 l2 =
//│                       ^^
//│   ◉ (?a * _) comes from
//│   │  - l.-31    else (l1, l2);;
//│   │                  ^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?b) is assumed for
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?d) is assumed for
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?e * _) comes from
//│      - l.-25  let add (l1,l2) =
//│                       ^^^^^^^
//│ ◉ (?e) is assumed for
//│    - l.-25  let add (l1,l2) =
//│                      ^^
//│   ◉ (?e * _) comes from
//│   ▲  - l.-25  let add (l1,l2) =
//│   │                   ^^^^^^^
//│   │  - l.-17  removeZero (add (padZero l1 l2));;
//│   │                           ^^^^^^^^^^^^^^^
//│   │  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?d) is assumed for
//│   ▲  - l.-36  if (List.length l1) > (List.length l2)
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │           then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│   │           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?b) is assumed for
//│   ▲  - l.-33    if (List.length l1) < (List.length l2)
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │             then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   │ 
//│   ◉ (?a * _) comes from
//│      - l.-31    else (l1, l2);;
//│                      ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.-37let padZero l1 l2 =
//│ │                     ^^
//│ │  - l.-33    if (List.length l1) < (List.length l2)
//│ │                             ^^
//│ ▼ 
//│ ◉ (_ list) comes from
//│    - lib. let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ -> _`
//│ 
//│         (int * _ list) ---> (?a) ~~~> (_ -> ?a) ~~~>  (?a -> _ -> ?a) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  ~~~> (?b) <--- (?d) <--- (?c) <--- (_ -> _)
//│ 
//│ ◉ (int * _ list) comes from
//│ │  - l.6    let base = (0, []) in
//│ │                      ^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?a -> _ -> ?a) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) comes from
//│        - l.2    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ ▲  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?d) is assumed for
//│ ▲  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) comes from
//│    - l.-26let bigAdd l1 l2 =
//│                         ^^^^
//│             let add (l1,l2) = ...
//│             ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ list`
//│ 
//│         (int * _ list) ---> (?a) ~~~> (_ -> ?a) ~~~>  (?a -> _ -> ?a) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  ~~~> (?b) <--- (?d) <--- (?c) <--- (_ list)
//│ 
//│ ◉ (int * _ list) comes from
//│ │  - l.6    let base = (0, []) in
//│ │                      ^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│    - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?a -> _ -> ?a) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) comes from
//│        - l.2    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ ▲  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?d) is assumed for
//│ ▲  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ list) comes from
//│    - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                     ^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?c) ---> (?d) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?a -> _ -> ?a)  <~~~ (_ -> ?a)  ~~~> (?a) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) comes from
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.3      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?b) comes from
//│     │  - l.2    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?c) ---> (?d) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?a -> _ -> ?a)  <~~~ (_ -> ?a)  ~~~> (?a) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.3      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?b) comes from
//│     │  - l.2    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│ │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                 ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) <--- (?a) ~~~> (?a -> _) ~~~>  (_ -> ?a -> _) ---> (?mulByDigit) ---> (_ -> ?b)  ~~~> (?b) ---> (?c -> _)  ~~~> (?c) ---> (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ ▲  - lib. let List.rev: 'a list -> 'a list
//│ │                       ^^^^^^^
//│ │  - l.-10  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ │                                                                        ^
//│ │ 
//│ ◉ (?a) is assumed for
//│    - l.-16let rec mulByDigit i l =
//│                                ^
//│   ◉ (?a -> _) comes from
//│      - l.-16let rec mulByDigit i l =
//│                                  ^^^
//│               let f a x = ...
//│               ^^^^^^^^^^^^^^^
//│     ◉ (_ -> ?a -> _) comes from
//│     │  - l.-16let rec mulByDigit i l =
//│     │                            ^^^^^
//│     │           let f a x = ...
//│     │           ^^^^^^^^^^^^^^^
//│     │  - l.-16let rec mulByDigit i l =
//│     │                 ^^^^^^^^^^
//│     ▼ 
//│     ◉ (?mulByDigit) is assumed for
//│     │  - l.-16let rec mulByDigit i l =
//│     │                 ^^^^^^^^^^
//│     ▼ 
//│     ◉ (_ -> ?b) comes from
//│        - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                               ^^^^^^^^^^
//│   ◉ (?b) is assumed for
//│   │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│   │                                                         ^^^^^^^^^^^^
//│   ▼ 
//│   ◉ (?c -> _) comes from
//│      - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                             ^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.1  let bigMul l1 l2 =
//│ │                    ^^
//│ ▼ 
//│ ◉ (_ -> _) comes from
//│    - l.7    let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│ 
//│         (_ -> _) ---> (?b) ---> (?d) ---> (?e) ~~~> (_ -> ?e) ~~~>  (?c -> _ -> ?e) ---> (?a -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <~~~ (?a -> _ -> ?a) <--- (?c -> _ -> ?e)  ~~~> (?c) ---> (_ * _)
//│ 
//│ ◉ (_ -> _) comes from
//│ │  - l.-26let bigAdd l1 l2 =
//│ │                       ^^^^
//│ │           let add (l1,l2) = ...
//│ │           ^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│    - l.3      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?e) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (?c -> _ -> ?e) comes from
//│     │  - l.2    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│   ◉ (?a -> _ -> ?a) comes from
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│   │                                            ^
//│   │ 
//│   ◉ (?c -> _ -> ?e) comes from
//│      - l.2    let f a x =
//│                     ^^^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.2    let f a x =
//│ │                 ^
//│ │  - l.4      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.4      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│ 
//│         (_ list) ---> (?b) ---> (?d) ---> (?e) ~~~> (_ -> ?e) ~~~>  (?c -> _ -> ?e) ---> (?a -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <~~~ (?a -> _ -> ?a) <--- (?c -> _ -> ?e)  ~~~> (?c) ---> (_ * _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?e) is assumed for
//│    - l.3      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?e) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (?c -> _ -> ?e) comes from
//│     │  - l.2    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│   ◉ (?a -> _ -> ?a) comes from
//│   ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│   │                               ^^^^^^^^^^^^^^
//│   │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│   │                                            ^
//│   │ 
//│   ◉ (?c -> _ -> ?e) comes from
//│      - l.2    let f a x =
//│                     ^^^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?c) is assumed for
//│ │  - l.2    let f a x =
//│ │                 ^
//│ │  - l.4      let (carry,res) = a in
//│ │                               ^
//│ ▼ 
//│ ◉ (_ * _) comes from
//│    - l.4      let (carry,res) = a in
//│                   ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│ 
//│         (_ list) ---> (?c) ---> (?d) ---> (?b) ~~~> (_ -> ?b) ~~~>  (_ -> _ -> ?b) ---> (?a -> _ -> ?a)  <~~~ (_ -> ?a)  <~~~ (?a) <~~~ (_ -> ?a) ~~~>  (?a -> _ -> ?a) <--- (_ -> _ -> ?b)  <~~~ (_ -> ?b)  ~~~> (?b) <--- (?d) <--- (?c) <--- (_ -> _)
//│ 
//│ ◉ (_ list) comes from
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                   ^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?c) is assumed for
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?d) is assumed for
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│    - l.3      let (x1,x2) = x in
//│               ^^^^^^^^^^^^^^^^^^
//│               let (carry,res) = a in ...
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│     ◉ (_ -> _ -> ?b) comes from
//│     │  - l.2    let f a x =
//│     │                 ^^^^^
//│     │             let (x1,x2) = x in ...
//│     │             ^^^^^^^^^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     ▼ 
//│     ◉ (?a -> _ -> ?a) comes from
//│        - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                     ^^^^^^^^^^^^^^
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│ ◉ (?a) is assumed for
//│   ◉ (_ -> ?a) comes from
//│      - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│                                         ^^^^^^^^
//│     ◉ (?a -> _ -> ?a) comes from
//│     ▲  - lib. let List.fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
//│     │                               ^^^^^^^^^^^^^^
//│     │  - l.8    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│     │                                            ^
//│     │ 
//│     ◉ (_ -> _ -> ?b) comes from
//│        - l.2    let f a x =
//│                       ^^^^^
//│                   let (x1,x2) = x in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^
//│   ◉ (_ -> ?b) comes from
//│      - l.2    let f a x =
//│                       ^^^
//│                 let (x1,x2) = x in ...
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│ ◉ (?b) is assumed for
//│ ▲  - l.3      let (x1,x2) = x in
//│ │             ^^^^^^^^^^^^^^^^^^
//│ │             let (carry,res) = a in ...
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?d) is assumed for
//│ ▲  - l.4      let (carry,res) = a in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^
//│ │             match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (?c) is assumed for
//│ ▲  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.5      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ │                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │ 
//│ ◉ (_ -> _) comes from
//│    - l.-26let bigAdd l1 l2 =
//│                         ^^^^
//│             let add (l1,l2) = ...
//│             ^^^^^^^^^^^^^^^^^^^^^
//│ bigMul: 'a -> list[int] -> list[int]
//│   where
//│     'a = list[int] -> list[('b, list[int],)], list['c]
//│ U max: 17, total: 275
//│ UERR 20 errors
//│ L: 2 [(α751' -> α809') ~ ([α824'], [α825'],), (α751' -> α809') <: α748', α748' <: α749', α749' <: α747', [α747' - (α744' -> α747') ~ (α740' -> α739') - α739', L: 1 [(α744' -> α747') ~ (α740' -> α739'), [(α744' -> α747') - (α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')) - (α740' -> α739'), L: 0 [(α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')), (α741' -> (α744' -> α747')) <: (α739' -> (α740' -> α739'))]]]], α739' <: ([α824'], [α825'],)]
//│ L: 1 [([α717'], [[[α615'']]],) ~ list[α620''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', [α634'' - ([[α634'']], [[α636'']],) ~ ([α635''], [α651''],) - α635'', L: 0 [([[α634'']], [[α636'']],) ~ ([α635''], [α651''],), ([[α634'']], [[α636'']],) <: α652'', α652'' <: α653'', α653'' <: ([α635''], [α651''],)]], [α635'' - ([α635''], [α651''],) ~ ([[α634'']], [[α636'']],) - α634'', L: 0 [([α635''], [α651''],) ~ ([[α634'']], [[α636'']],), ([α635''], [α651''],) :> α653'', α653'' :> α652'', α652'' :> ([[α634'']], [[α636'']],)]], α634'' <: list[α620'']]
//│ L: 0 [([α717'], [[[α615'']]],) ~ list[α620''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', α634'' <: list[α620'']]
//│ L: 2 [([[int]], [[list['a822']]],) ~ (α751' -> α809'), ([[int]], [[list['a822']]],) <: α739', [α739' - (α740' -> α739') ~ (α744' -> α747') - α747', L: 1 [(α740' -> α739') ~ (α744' -> α747'), [(α740' -> α739') - (α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')) - (α744' -> α747'), L: 0 [(α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')), (α739' -> (α740' -> α739')) :> (α741' -> (α744' -> α747'))]]]], α747' :> α749', α749' :> α748', α748' :> (α751' -> α809')]
//│ L: 0 [([α717'], [[[α615'']]],) ~ list[α687''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', α634'' <: list[α687'']]
//│ L: 0 [([α717'], [[[α615'']]],) ~ list[α621''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', α634'' <: list[α621'']]
//│ L: 1 [([α717'], [[[α615'']]],) ~ list[α633''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', [α634'' - ([[α634'']], [[α636'']],) ~ ([α635''], [α651''],) - α635'', L: 0 [([[α634'']], [[α636'']],) ~ ([α635''], [α651''],), ([[α634'']], [[α636'']],) <: α652'', α652'' <: α653'', α653'' <: ([α635''], [α651''],)]], [α635'' - ([α635''], [α651''],) ~ ([[α634'']], [[α636'']],) - α634'', L: 0 [([α635''], [α651''],) ~ ([[α634'']], [[α636'']],), ([α635''], [α651''],) :> α653'', α653'' :> α652'', α652'' :> ([[α634'']], [[α636'']],)]], α634'' <: list[α633'']]
//│ L: 2 [list['a750'] ~ (α751' -> α809'), list['a750'] <: α748', α748' <: α749', α749' <: α747', [α747' - (α744' -> α747') ~ (α740' -> α739') - α739', L: 1 [(α744' -> α747') ~ (α740' -> α739'), [(α744' -> α747') - (α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')) - (α740' -> α739'), L: 0 [(α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')), (α741' -> (α744' -> α747')) <: (α739' -> (α740' -> α739'))]]]], [α739' - (α740' -> α739') ~ (α744' -> α747') - α747', L: 1 [(α740' -> α739') ~ (α744' -> α747'), [(α740' -> α739') - (α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')) - (α744' -> α747'), L: 0 [(α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')), (α739' -> (α740' -> α739')) :> (α741' -> (α744' -> α747'))]]]], α747' :> α749', α749' :> α748', α748' :> (α751' -> α809')]
//│ L: 0 [([α717'], [[[α615'']]],) ~ list[α688''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', α634'' <: list[α688'']]
//│ L: 1 [([α717'], [[[α615'']]],) ~ list[α632''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', [α634'' - ([[α634'']], [[α636'']],) ~ ([α635''], [α651''],) - α635'', L: 0 [([[α634'']], [[α636'']],) ~ ([α635''], [α651''],), ([[α634'']], [[α636'']],) <: α652'', α652'' <: α653'', α653'' <: ([α635''], [α651''],)]], α635'' <: list[α632'']]
//│ L: 2 [(α751' -> α809') ~ ([α742'], [α743'],), (α751' -> α809') <: α748', α748' <: α749', α749' <: α747', [α747' - (α744' -> α747') ~ (α740' -> α739') - α739', L: 1 [(α744' -> α747') ~ (α740' -> α739'), [(α744' -> α747') - (α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')) - (α740' -> α739'), L: 0 [(α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')), (α741' -> (α744' -> α747')) <: (α739' -> (α740' -> α739'))]]]], [α739' - (α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')) - α741', L: 0 [(α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')), (α739' -> (α740' -> α739')) :> (α741' -> (α744' -> α747'))]], α741' <: ([α742'], [α743'],)]
//│ L: 2 [list['a750'] ~ ([α824'], [α825'],), list['a750'] <: α748', α748' <: α749', α749' <: α747', [α747' - (α744' -> α747') ~ (α740' -> α739') - α739', L: 1 [(α744' -> α747') ~ (α740' -> α739'), [(α744' -> α747') - (α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')) - (α740' -> α739'), L: 0 [(α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')), (α741' -> (α744' -> α747')) <: (α739' -> (α740' -> α739'))]]]], α739' <: ([α824'], [α825'],)]
//│ L: 1 [([α717'], [[[α615'']]],) ~ list[α687''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', [α634'' - ([[α634'']], [[α636'']],) ~ ([α635''], [α651''],) - α635'', L: 0 [([[α634'']], [[α636'']],) ~ ([α635''], [α651''],), ([[α634'']], [[α636'']],) <: α652'', α652'' <: α653'', α653'' <: ([α635''], [α651''],)]], [α635'' - ([α635''], [α651''],) ~ ([[α634'']], [[α636'']],) - α634'', L: 0 [([α635''], [α651''],) ~ ([[α634'']], [[α636'']],), ([α635''], [α651''],) :> α653'', α653'' :> α652'', α652'' :> ([[α634'']], [[α636'']],)]], α634'' <: list[α687'']]
//│ L: 1 [([α717'], [[[α615'']]],) ~ list[α621''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', [α634'' - ([[α634'']], [[α636'']],) ~ ([α635''], [α651''],) - α635'', L: 0 [([[α634'']], [[α636'']],) ~ ([α635''], [α651''],), ([[α634'']], [[α636'']],) <: α652'', α652'' <: α653'', α653'' <: ([α635''], [α651''],)]], [α635'' - ([α635''], [α651''],) ~ ([[list[α621'']]], [[α636'']],) - list[α621''], L: 0 [([α635''], [α651''],) ~ ([[list[α621'']]], [[α636'']],), ([α635''], [α651''],) :> α653'', α653'' :> α652'', α652'' :> ([[list[α621'']]], [[α636'']],)]]]
//│ L: 0 [([α717'], [[[α615'']]],) ~ list[α633''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', α634'' <: list[α633'']]
//│ L: 0 [(α685'' -> α674'') ~ list['a618''], (α685'' -> α674'') <: α616'', α616'' :> list['a618'']]
//│ L: 2 [list['a750'] ~ ([α742'], [α743'],), list['a750'] <: α748', α748' <: α749', α749' <: α747', [α747' - (α744' -> α747') ~ (α740' -> α739') - α739', L: 1 [(α744' -> α747') ~ (α740' -> α739'), [(α744' -> α747') - (α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')) - (α740' -> α739'), L: 0 [(α741' -> (α744' -> α747')) ~ (α739' -> (α740' -> α739')), (α741' -> (α744' -> α747')) <: (α739' -> (α740' -> α739'))]]]], [α739' - (α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')) - α741', L: 0 [(α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')), (α739' -> (α740' -> α739')) :> (α741' -> (α744' -> α747'))]], α741' <: ([α742'], [α743'],)]
//│ L: 2 [list[α693'] ~ (α737' -> α738'), list[α693'] :> α692', [α692' - (α692' -> α703') ~ ([α606'] -> α717') - α606', L: 1 [(α692' -> α703') ~ ([α606'] -> α717'), [(α692' -> α703') - (α691' -> (α692' -> α703')) ~ (['a617'] -> α716') - α716', L: 0 [(α691' -> (α692' -> α703')) ~ (['a617'] -> α716'), (α691' -> (α692' -> α703')) <: mulByDigit690', mulByDigit690' <: (['a617'] -> α716')]], α716' <: ([α606'] -> α717')]], α606' <: (α737' -> α738')]
//│ L: 1 [([α717'], [[[α615'']]],) ~ list[α688''], ([α717'], [[[α615'']]],) <: α619'', α619'' <: α634'', [α634'' - ([[α634'']], [[α636'']],) ~ ([α635''], [α651''],) - α635'', L: 0 [([[α634'']], [[α636'']],) ~ ([α635''], [α651''],), ([[α634'']], [[α636'']],) <: α652'', α652'' <: α653'', α653'' <: ([α635''], [α651''],)]], [α635'' - ([α635''], [α651''],) ~ ([[α634'']], [[α636'']],) - α634'', L: 0 [([α635''], [α651''],) ~ ([[α634'']], [[α636'']],), ([α635''], [α651''],) :> α653'', α653'' :> α652'', α652'' :> ([[α634'']], [[α636'']],)]], α634'' <: list[α688'']]
//│ L: 2 [([[int]], [[list['a822']]],) ~ list['a750'], ([[int]], [[list['a822']]],) <: α739', [α739' - (α740' -> α739') ~ (α744' -> α747') - α747', L: 1 [(α740' -> α739') ~ (α744' -> α747'), [(α740' -> α739') - (α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')) - (α744' -> α747'), L: 0 [(α739' -> (α740' -> α739')) ~ (α741' -> (α744' -> α747')), (α739' -> (α740' -> α739')) :> (α741' -> (α744' -> α747'))]]]], α747' :> α749', α749' :> α748', α748' :> list['a750']]

////////// file 2361

////////// ocamlc error
// 
// File "2361.ml", line 12, characters 46-51:
// 12 |   | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//                                                    ^^^^^
// Error: This expression has type bool but an expression was expected of type
//          int

let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]

:unify
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ [ERROR] Type `bool` does not match `int`
//│ 
//│         (bool) ---> (?b) ---> (?a) <--- (int)
//│ 
//│ ◉ (bool) comes from
//│ │  - l.4    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                                                       ^^^^^
//│ │  - l.4    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?b) is assumed for
//│ │  - l.4    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ │                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ │  - l.2    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ ▼ 
//│ ◉ (?a) is assumed for
//│ ▲  - l.2    match digits n with
//│ │           ^^^^^^^^^^^^^^^^^^^
//│ │           | [] -> 0 ...
//│ │           ^^^^^^^^^^^^^
//│ │ 
//│ ◉ (int) comes from
//│    - l.3    | [] -> 0
//│                     ^
//│ additivePersistence: 'a -> 'b
//│   where
//│     'b = bool, int
//│ U max: 6, total: 56
//│ UERR 1 errors
//│ L: 0 [bool ~ int, bool <: α891', α891' <: α881', α881' :> int]
