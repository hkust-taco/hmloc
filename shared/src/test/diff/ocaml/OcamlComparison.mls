////////// file 1935

////////// ocamlc error
//
// File "1935.ml", line 22, characters 18-44:
// 22 |     let (_,res) = List.fold_left f base args in res in
//                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type int but an expression was expected of type
//          'a * 'b

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ ╔══[ERROR] Type `_ * _ list` does not match `_ list * _`
//│ ║  
//│ ╟──        _ * _ list ---> ?a <--- _ list * _ 
//│ ║  
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.5:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.4:	  if (List.length l1) > (List.length l2)
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `_ list * _` flows into `?a`
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ list * _`] comes from this tuple literal
//│ ║  l.8:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ╙──    	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _ list` does not match `_ * _`
//│ ║  
//│ ╟──        _ * _ list ---> ?a <--- _ * _ 
//│ ║  
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.5:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.4:	  if (List.length l1) > (List.length l2)
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `_ * _` flows into `?a`
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _`] comes from this tuple literal
//│ ║  l.9:	    else (l1, l2);;
//│ ╙──    	         ^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list * _`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ list * _ 
//│ ║  
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.9:	    else (l1, l2);;
//│ ║      	         ^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ list * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.8:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ╙──    	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]


let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ ╔══[ERROR] Type `_ * _` does not match `_ list * _`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ list * _ 
//│ ║  
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-63:	    else (l1, l2);;
//│ ║        	         ^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.-65:	    if (List.length l1) < (List.length l2)
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ list * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-64:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ╙──      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal
//│ ║  l.-64:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `_ list * _` and it flows into `?a`
//│ ║  l.-65:	    if (List.length l1) < (List.length l2)
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.-68:	  if (List.length l1) > (List.length l2)
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-67:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ * _`] comes from this tuple literal
//│ ║  l.-63:	    else (l1, l2);;
//│ ║        	         ^^^^^^^^
//│ ╟── so this if-then-else expression has type `_ * _` and it flows into `?a`
//│ ║  l.-65:	    if (List.length l1) < (List.length l2)
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.-68:	  if (List.length l1) > (List.length l2)
//│ ║        	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-67:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `int`
//│ ║  
//│ ╟──        _ * _ <--- ?a ---> int 
//│ ║  
//│ ╟── [`_ * _`] comes from this pattern. However `?a` flows into `_ * _`
//│ ║  l.6:	    let (_,res) = List.fold_left f base args in res in
//│ ║      	        ^^^^^^^
//│ ╟── [`?a`] comes from this application
//│ ║  l.6:	    let (_,res) = List.fold_left f base args in res in
//│ ║      	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this variable has type `?a`
//│ ║  l.3:	    let f a x = (a + x) mod 10 in
//│ ║      	          ^
//│ ╟── so this reference has type `?a` and it flows into `int`
//│ ║  l.3:	    let f a x = (a + x) mod 10 in
//│ ║      	                 ^
//│ ╟── [`int`] comes from this type reference
//│ ║  builtin:	let (+): int -> int -> int
//│ ╙──        	         ^^^
//│ bigAdd: list[int] -> list[int] -> list[nothing]

////////// file 0003

////////// ocamlc error
//
// File "0003.ml", line 23, characters 31-32:
// 23 |         (let (toSum1,toSum2) = x in
//                                     ^
// Error: This expression has type 'a list
//        but an expression was expected of type 'b * 'c

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║      	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║      	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──    	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║      	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `_ list * _` and it flows into `?a`
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║      	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.5:	  if numZeros = 0
//│ ║      	  ^^^^^^^^^^^^^^^
//│ ║      	  then (l1, l2) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.6:	  then (l1, l2)
//│ ╙──    	       ^^^^^^^^
//│ ╔══[ERROR] Type `_ * _ list` does not match `_ * _`
//│ ║  
//│ ╟──        _ * _ list ---> ?a <--- _ * _ 
//│ ║  
//│ ╟── [`_ * _ list`] comes from this tuple literal
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║      	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `_ * _ list` and it flows into `?a`
//│ ║  l.9:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║      	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.5:	  if numZeros = 0
//│ ║      	  ^^^^^^^^^^^^^^^
//│ ║      	  then (l1, l2) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.6:	  then (l1, l2)
//│ ╙──    	       ^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: (list[int] & 'a & 'b) -> 'a
//│   where
//│     'a := 'b
//│     'b := 'a

:unify
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║        	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──      	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list * _`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ list * _ 
//│ ║  
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-62:	  then (l1, l2)
//│ ║        	       ^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.-63:	  if numZeros = 0
//│ ║        	  ^^^^^^^^^^^^^^^
//│ ║      	  then (l1, l2) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `_ list * _` flows into `?a`
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ list * _`] comes from this tuple literal
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──      	                                                      ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.-62:	  then (l1, l2)
//│ ║        	       ^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.-63:	  if numZeros = 0
//│ ║        	  ^^^^^^^^^^^^^^^
//│ ║      	  then (l1, l2) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `_ * _ list` flows into `?a`
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal
//│ ║  l.-59:	     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│ ╙──      	                          ^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `int * _ list` does not match `int * _ list`
//│ ║  
//│ ╟──        int * _ list ---> ?a <--- int * _ list 
//│ ║  
//│ ╟── [`int * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.13:	    let base = (0, []) in
//│ ║       	               ^^^^^^^
//│ ╟── [`?a`] comes from this reference
//│ ║  l.15:	    let (_,res) = List.fold_left f base args in res in
//│ ║       	                                   ^^^^
//│ ╟── so this let expression has type `?a`
//│ ║  l.4:	      let (carry,currentSum) = a in
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	      if x = [] ...
//│ ║      	      ^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `int * _ list` flows into `?a`
//│ ║  l.5:	      if x = []
//│ ║      	      ^^^^^^^^^
//│ ║      	      then (0, (carry :: currentSum)) ...
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int * _ list`] comes from this tuple literal
//│ ║  l.6:	      then (0, (carry :: currentSum))
//│ ╙──    	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `int * _ list` does not match `int * _ list`
//│ ║  
//│ ╟──        int * _ list ---> ?a <--- int * _ list 
//│ ║  
//│ ╟── [`int * _ list`] comes from this tuple literal
//│ ║  l.12:	         (carry, (valueToAddToArray :: currentSum))) in
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this let expression has type `int * _ list`
//│ ║  l.8:	        (let (toSum1,toSum2) = x in
//│ ║      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	         let intermediateValue = (toSum1 + toSum2) + carry in ...
//│ ║      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `int * _ list` and it flows into `?a`
//│ ║  l.5:	      if x = []
//│ ║      	      ^^^^^^^^^
//│ ║      	      then (0, (carry :: currentSum)) ...
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this let expression
//│ ║  l.4:	      let (carry,currentSum) = a in
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	      if x = [] ...
//│ ║      	      ^^^^^^^^^^^^^
//│ ╟── so this reference has type `?a`. However `int * _ list` flows into `?a`
//│ ║  l.15:	    let (_,res) = List.fold_left f base args in res in
//│ ║       	                                   ^^^^
//│ ╟── [`int * _ list`] comes from this tuple literal
//│ ║  l.13:	    let base = (0, []) in
//│ ╙──     	               ^^^^^^^
//│ ╔══[ERROR] Type `int * _ list` does not match `int * _ list`
//│ ║  
//│ ╟──        int * _ list ---> ?a <--- int * _ list 
//│ ║  
//│ ╟── [`int * _ list`] comes from this tuple literal
//│ ║  l.12:	         (carry, (valueToAddToArray :: currentSum))) in
//│ ║       	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this let expression has type `int * _ list` and it flows into `?a`
//│ ║  l.8:	        (let (toSum1,toSum2) = x in
//│ ║      	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	         let intermediateValue = (toSum1 + toSum2) + carry in ...
//│ ║      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.5:	      if x = []
//│ ║      	      ^^^^^^^^^
//│ ║      	      then (0, (carry :: currentSum)) ...
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.6:	      then (0, (carry :: currentSum))
//│ ╙──    	           ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ list 
//│ ║  
//│ ╟── [`_ * _`] comes from this type expression
//│ ║  builtin:	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║          	                                         ^^^^^^^
//│ ╟── so this variable has type `_ * _` and it flows into `?a`
//│ ║  l.3:	    let f a x =
//│ ║      	            ^
//│ ╟── [`?a`] comes from this reference
//│ ║  l.5:	      if x = []
//│ ║      	         ^
//│ ╟── [`_ list`] comes from this reference and it flows into `?a`
//│ ║  l.5:	      if x = []
//│ ╙──    	             ^^
//│ ╔══[ERROR] Type `_ list` does not match `_ * _`
//│ ║  
//│ ╟──        _ list ---> ?a <--- ?b ---> _ * _ 
//│ ║  
//│ ╟── [`_ list`] comes from this reference and it flows into `?a`
//│ ║  l.5:	      if x = []
//│ ║      	             ^^
//│ ╟── so this reference has type `?a`. However `?b` flows into `?a`
//│ ║  l.5:	      if x = []
//│ ║      	         ^
//│ ╟── [`?b`] comes from this variable
//│ ║  l.3:	    let f a x =
//│ ║      	            ^
//│ ╟── so this reference has type `?b` and it flows into `_ * _`
//│ ║  l.8:	        (let (toSum1,toSum2) = x in
//│ ║      	                               ^
//│ ╟── [`_ * _`] comes from this pattern
//│ ║  l.8:	        (let (toSum1,toSum2) = x in
//│ ╙──    	             ^^^^^^^^^^^^^^^
//│ bigAdd: list[int] -> list[int] -> list[int]

////////// file 1948

////////// ocamlc error
//
// File "1948.ml", line 43, characters 46-70:
// 43 |     match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//                                                    ^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type 'a * 'b
//        but an expression was expected of type int list

let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (x1,x2) = x in
      let (carry,res) = a in
      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (carry,res) = List.fold_left f base args in [carry] @ res in
  removeZero (add (padZero l1 l2));;
let rec mulByDigit i l =
  let f a x =
    let carry = i * x in
    match a with
    | h::t -> ((h + carry) / 10) :: (mod (h + carry) 10) :: t
    | _ -> [carry / 10; mod carry 10] in
  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.8:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.9:	    else (l1, l2);;
//│ ╙──    	         ^^^^^^^^
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.8:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _`] comes from this tuple literal and it flows into `?a`
//│ ║  l.9:	    else (l1, l2);;
//│ ╙──    	         ^^^^^^^^
//│ ╔══[ERROR] Type `_ * _ list` does not match `_ list * _`
//│ ║  
//│ ╟──        _ * _ list ---> ?a <--- _ list * _ 
//│ ║  
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.5:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.4:	  if (List.length l1) > (List.length l2)
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `_ list * _` flows into `?a`
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ list * _`] comes from this tuple literal
//│ ║  l.8:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ╙──    	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _ list` does not match `_ * _`
//│ ║  
//│ ╟──        _ * _ list ---> ?a <--- _ * _ 
//│ ║  
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.5:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.4:	  if (List.length l1) > (List.length l2)
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `?a`. However `_ * _` flows into `?a`
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _`] comes from this tuple literal
//│ ║  l.9:	    else (l1, l2);;
//│ ╙──    	         ^^^^^^^^
//│ ╔══[ERROR] Type `int * _ list` does not match `int * _ list`
//│ ║  
//│ ╟──        int * _ list ---> ?a <--- int * _ list 
//│ ║  
//│ ╟── [`int * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.20:	    let base = (0, []) in
//│ ║       	               ^^^^^^^
//│ ╟── [`?a`] comes from this reference
//│ ║  l.22:	    let (carry,res) = List.fold_left f base args in [carry] @ res in
//│ ║       	                                       ^^^^
//│ ╟── so this let expression has type `?a`
//│ ║  l.17:	      let (x1,x2) = x in
//│ ║       	      ^^^^^^^^^^^^^^^^^^
//│ ║      	      let (carry,res) = a in ...
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this let expression has type `?a`. However `int * _ list` flows into `?a`
//│ ║  l.18:	      let (carry,res) = a in
//│ ║       	      ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
//│ ║      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`int * _ list`] comes from this tuple literal
//│ ║  l.19:	      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
//│ ╙──     	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ list * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ list * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ list * _`] comes from this tuple literal
//│ ║  l.8:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║      	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this if-then-else expression has type `_ list * _` and it flows into `?a`
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.4:	  if (List.length l1) > (List.length l2)
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.5:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ╙──    	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ * _ list`
//│ ║  
//│ ╟──        _ * _ ---> ?a <--- _ * _ list 
//│ ║  
//│ ╟── [`_ * _`] comes from this tuple literal
//│ ║  l.9:	    else (l1, l2);;
//│ ║      	         ^^^^^^^^
//│ ╟── so this if-then-else expression has type `_ * _` and it flows into `?a`
//│ ║  l.7:	    if (List.length l1) < (List.length l2)
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this if-then-else expression
//│ ║  l.4:	  if (List.length l1) > (List.length l2)
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.5:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ╙──    	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ helper: int -> int
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]
//│ tenEx: int -> list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ mulByDigit: int -> list[int] -> list[int]

// FIXME: no common provs
:unify
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ╔══[ERROR] Type `int * _ list` does not match `_ -> _`
//│ ║  
//│ ╟──        int * _ list ---> ?a <--- _ -> _ 
//│ ║  
//│ ╟── [`int * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.6:	  let base = (0, []) in
//│ ║      	             ^^^^^^^
//│ ╟── [`?a`] comes from this reference
//│ ║  l.8:	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║      	                                     ^^^^
//│ ╟── so this let expression has type `?a`
//│ ║  l.3:	    let (x1,x2) = x in
//│ ║      	    ^^^^^^^^^^^^^^^^^^
//│ ║      	    let (carry,res) = a in ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this let expression has type `?a`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this match expression has type `?a`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this application has type `?a`. However `_ -> _` flows into `?a`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ -> _`] comes from this function
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	              ^^^^
//│ ║      	  let add (l1,l2) = ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `int * _ list` does not match `_ list`
//│ ║  
//│ ╟──        int * _ list ---> ?a <--- _ list 
//│ ║  
//│ ╟── [`int * _ list`] comes from this tuple literal and it flows into `?a`
//│ ║  l.6:	  let base = (0, []) in
//│ ║      	             ^^^^^^^
//│ ╟── [`?a`] comes from this reference
//│ ║  l.8:	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║      	                                     ^^^^
//│ ╟── so this let expression has type `?a`
//│ ║  l.3:	    let (x1,x2) = x in
//│ ║      	    ^^^^^^^^^^^^^^^^^^
//│ ║      	    let (carry,res) = a in ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this let expression has type `?a`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this match expression has type `?a`. However `_ list` flows into `?a`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ list`] comes from this reference
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ╙──    	                          ^^
//│ ╔══[ERROR] Type `_ -> _` does not match `_ list`
//│ ║  
//│ ╟──        _ -> _ <--- ?a ---> _ list 
//│ ║  
//│ ╟── [`_ -> _`] comes from this reference. However `?a` flows into `_ -> _`
//│ ║  l.7:	  let args = l1 (tenEx 0 l2) in
//│ ║      	             ^^
//│ ╟── [`?a`] comes from this variable
//│ ║  l.1:	let bigMul l1 l2 =
//│ ║      	           ^^
//│ ╟── so this reference has type `?a`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                                             ^^
//│ ╟── so this variable has type `?a`
//│ ║  l.-149:	let rec mulByDigit i l =
//│ ║         	                     ^
//│ ╟── so this reference has type `?a` and it flows into `_ list`
//│ ║  l.-143:	  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ ║         	                                                               ^
//│ ╟── [`_ list`] comes from this applied type reference
//│ ║  builtin:	let List.rev: 'a list -> 'a list
//│ ╙──        	              ^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ -> _`
//│ ║  
//│ ╟── this pattern has type `_ * _`
//│ ║  l.8:	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║      	      ^^^^^^^^^^^
//│ ╟── so this application has type `_ * _`
//│ ║  l.8:	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║      	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but this let expression has type `_ -> _`
//│ ║  l.3:	    let (x1,x2) = x in
//│ ║      	    ^^^^^^^^^^^^^^^^^^
//│ ║      	    let (carry,res) = a in ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this let expression has type `_ -> _`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this match expression has type `_ -> _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this application has type `_ -> _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this function has type `_ -> _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	              ^^^^
//│ ║      	  let add (l1,l2) = ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list`
//│ ║  
//│ ╟── this pattern has type `_ * _`
//│ ║  l.8:	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║      	      ^^^^^^^^^^^
//│ ╟── so this application has type `_ * _`
//│ ║  l.8:	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║      	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but this let expression has type `_ list`
//│ ║  l.3:	    let (x1,x2) = x in
//│ ║      	    ^^^^^^^^^^^^^^^^^^
//│ ║      	    let (carry,res) = a in ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this let expression has type `_ list`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this match expression has type `_ list`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this reference has type `_ list`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ╙──    	                          ^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list`
//│ ║  
//│ ╟── this tuple literal has type `_ * _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	           ^^
//│ ╟── so this reference has type `_ * _`
//│ ║  l.-150:	  removeZero (add (padZero l1 l2));;
//│ ║         	                           ^^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── but this variable has type `_ list`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── because this reference has type `_ list`
//│ ║  l.-164:	    else (l1, l2);;
//│ ║         	          ^^
//│ ╟── because this variable has type `_ list`
//│ ║  l.-158:	  let add (l1,l2) =
//│ ║         	           ^^
//│ ╟── because this reference has type `_ list`
//│ ║  l.-152:	    let args = List.rev (List.combine l1 l2) in
//│ ║         	                                      ^^
//│ ╟── because `_ list` comes from this type expression
//│ ║  builtin:	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ╙──        	                  ^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list`
//│ ║  
//│ ╟── this tuple literal has type `_ * _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	           ^^
//│ ╟── so this reference has type `_ * _`
//│ ║  l.-150:	  removeZero (add (padZero l1 l2));;
//│ ║         	                           ^^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── but this variable has type `_ list`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── because this reference has type `_ list`
//│ ║  l.-165:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║         	                                                             ^^
//│ ╟── because `_ list` comes from this type expression
//│ ║  builtin:	let (@): 'a list -> 'a list -> 'a list
//│ ╙──        	                    ^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list`
//│ ║  
//│ ╟── this tuple literal has type `_ * _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	           ^^
//│ ╟── so this reference has type `_ * _`
//│ ║  l.-150:	  removeZero (add (padZero l1 l2));;
//│ ║         	                           ^^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── but this variable has type `_ list`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── because this reference has type `_ list`
//│ ║  l.-166:	    if (List.length l1) < (List.length l2)
//│ ║         	                    ^^
//│ ╟── because `_ list` comes from this type expression
//│ ║  builtin:	let List.length: 'a list -> int
//│ ╙──        	                 ^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ -> _`
//│ ║  
//│ ╟── this pattern has type `_ * _`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	        ^^^^^^^^^^^
//│ ╟── so this reference has type `_ * _`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	                      ^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.2:	  let f a x =
//│ ║      	        ^
//│ ╟── but this let expression has type `_ -> _`
//│ ║  l.3:	    let (x1,x2) = x in
//│ ║      	    ^^^^^^^^^^^^^^^^^^
//│ ║      	    let (carry,res) = a in ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this let expression has type `_ -> _`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this match expression has type `_ -> _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this application has type `_ -> _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this function has type `_ -> _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	              ^^^^
//│ ║      	  let add (l1,l2) = ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ * _` does not match `_ list`
//│ ║  
//│ ╟── this pattern has type `_ * _`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	        ^^^^^^^^^^^
//│ ╟── so this reference has type `_ * _`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	                      ^
//│ ╟── so this variable has type `_ * _`
//│ ║  l.2:	  let f a x =
//│ ║      	        ^
//│ ╟── but this let expression has type `_ list`
//│ ║  l.3:	    let (x1,x2) = x in
//│ ║      	    ^^^^^^^^^^^^^^^^^^
//│ ║      	    let (carry,res) = a in ...
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this let expression has type `_ list`
//│ ║  l.4:	    let (carry,res) = a in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║      	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this match expression has type `_ list`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because this reference has type `_ list`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ╙──    	                          ^^
//│ ╔══[ERROR] Type `_ list` does not match `_ -> _`
//│ ║  
//│ ╟──        _ list ---> ?a <--- _ -> _ 
//│ ║  
//│ ╟── [`_ list`] comes from this reference and it flows into `?a`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                          ^^
//│ ╟── [`?a`] comes from this match expression
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── so this application has type `?a`. However `_ -> _` flows into `?a`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║      	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`_ -> _`] comes from this function
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	              ^^^^
//│ ║      	  let add (l1,l2) = ...
//│ ║      	  ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ list` does not match `_ * _`
//│ ║  
//│ ╟── `_ list` comes from this type expression
//│ ║  builtin:	let List.length: 'a list -> int
//│ ║          	                 ^^^^^^^
//│ ╟── so this reference has type `_ list`
//│ ║  l.-165:	    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│ ║         	                                                     ^^
//│ ╟── so this variable has type `_ list`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── but this variable has type `_ * _`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── because this reference has type `_ * _`
//│ ║  l.-150:	  removeZero (add (padZero l1 l2));;
//│ ║         	                           ^^
//│ ╟── because this variable has type `_ * _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	           ^^
//│ ╟── because this tuple literal has type `_ * _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ╙──    	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ list` does not match `_ * _`
//│ ║  
//│ ╟── `_ list` comes from this type expression
//│ ║  builtin:	let List.length: 'a list -> int
//│ ║          	                 ^^^^^^^
//│ ╟── so this reference has type `_ list`
//│ ║  l.-168:	  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│ ║         	                                    ^^
//│ ╟── so this variable has type `_ list`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── but this variable has type `_ * _`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── because this reference has type `_ * _`
//│ ║  l.-150:	  removeZero (add (padZero l1 l2));;
//│ ║         	                           ^^
//│ ╟── because this variable has type `_ * _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	           ^^
//│ ╟── because this tuple literal has type `_ * _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ╙──    	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `_ list` does not match `_ * _`
//│ ║  
//│ ╟── `_ list` comes from this type expression
//│ ║  builtin:	let List.length: 'a list -> int
//│ ║          	                 ^^^^^^^
//│ ╟── so this reference has type `_ list`
//│ ║  l.-169:	  if (List.length l1) > (List.length l2)
//│ ║         	                  ^^
//│ ╟── so this variable has type `_ list`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── but this variable has type `_ * _`
//│ ║  l.-170:	let padZero l1 l2 =
//│ ║         	            ^^
//│ ╟── because this reference has type `_ * _`
//│ ║  l.-150:	  removeZero (add (padZero l1 l2));;
//│ ║         	                           ^^
//│ ╟── because this variable has type `_ * _`
//│ ║  l.-159:	let bigAdd l1 l2 =
//│ ║         	           ^^
//│ ╟── because this tuple literal has type `_ * _`
//│ ║  l.5:	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ╙──    	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ bigMul: nothing -> list[int] -> list[int]

////////// file 2361

////////// ocamlc error
// 
// File "2361.ml", line 12, characters 46-51:
// 12 |   | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//                                                    ^^^^^
// Error: This expression has type bool but an expression was expected of type
//          int

let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]

:unify
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── [`bool`] comes from this `else` branch
//│ ║  l.4:	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ║      	                                                         ^^^^
//│ ╟── so this if-then-else expression has type `bool` and it flows into `?a`
//│ ║  l.4:	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ ║      	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── [`?a`] comes from this match expression
//│ ║  l.2:	  match digits n with
//│ ║      	  ^^^^^^^^^^^^^^^^^^^
//│ ║      	  | [] -> 0 ...
//│ ║      	  ^^^^^^^^^^^^^
//│ ╟── [`int`] comes from this integer literal and it flows into `?a`
//│ ║  l.3:	  | [] -> 0
//│ ╙──    	          ^
//│ additivePersistence: int -> (bool | int)
