:AllowTypeErrors

def succ: int -> int
//│ succ: int -> int


x1 = false
x2 = x1
x3 = x2
//│ x1: false
//│ x2: false
//│ x3: false

:ex
succ x3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	succ x3
//│ ║        	^^^^^^^
//│ ╟── reference of type `false` is not a 1-element tuple
//│ ║  l.7: 	x1 = false
//│ ║       	     ^^^^^
//│ ╟── but it flows into reference with expected type `(int,)`
//│ ║  l.15: 	succ x3
//│ ║        	     ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from type `false`
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.7: 	x1 = false
//│ ║       	     ^^^^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.8: 	x2 = x1
//│ ║       	     ^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.9: 	x3 = x2
//│ ║       	     ^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.15: 	succ x3
//│ ║        	     ^^
//│ ╟── [info] flowing from argument of type `(false,)`
//│ ║  l.15: 	succ x3
//│ ║        	     ^^
//│ ╟── [info] flowing from <nested> of type `(false,)`
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `(int,)`
//│ ║  l.3: 	def succ: int -> int
//│ ╙──     	          ^^^
//│ res: error | int












f1 y1 = succ y1
f2 y2 = f1 y2
f3 y3 = f2 y3
//│ f1: int -> int
//│ f2: int -> int
//│ f3: int -> int

:ex
f3 true
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.88: 	f3 true
//│ ║        	^^^^^^^
//│ ╟── reference of type `true` is not a 1-element tuple
//│ ║  l.88: 	f3 true
//│ ║        	   ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── from type reference:
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from type `true`
//│ ╟── [info] flowing from reference of type `true`
//│ ║  l.88: 	f3 true
//│ ║        	   ^^^^
//│ ╟── [info] flowing from argument of type `(true,)`
//│ ║  l.88: 	f3 true
//│ ║        	   ^^^^
//│ ╟── [info] flowing from <nested> of type `(true,)`
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into <nested> of type `int`
//│ ╟── [info] flowing into argument of type `int`
//│ ║  l.80: 	f1 y1 = succ y1
//│ ║        	             ^^
//│ ╟── [info] flowing into reference of type `int`
//│ ║  l.80: 	f1 y1 = succ y1
//│ ║        	             ^^
//│ ╟── [info] flowing into variable of type `int`
//│ ╟── [info] flowing into variable of type `?a`
//│ ╟── [info] flowing into variable of type `?b`
//│ ╟── [info] flowing into variable of type `?c`
//│ ╟── [info] flowing into <nested> of type `?d`
//│ ╟── [info] flowing into argument of type `?e`
//│ ║  l.81: 	f2 y2 = f1 y2
//│ ║        	           ^^
//│ ╟── [info] flowing into reference of type `?f`
//│ ║  l.81: 	f2 y2 = f1 y2
//│ ║        	           ^^
//│ ╟── [info] flowing into variable of type `?g`
//│ ╟── [info] flowing into variable of type `?h`
//│ ╟── [info] flowing into variable of type `?i`
//│ ╟── [info] flowing into variable of type `?j`
//│ ╟── [info] flowing into <nested> of type `?k`
//│ ╟── [info] flowing into argument of type `?l`
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── [info] flowing into reference of type `?m`
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── [info] flowing into variable of type `?n`
//│ ╟── [info] flowing into variable of type `?o`
//│ ╟── [info] flowing into variable of type `?p`
//│ ╙── [info] flowing into expression of type `(?q,)`
//│ res: error | int













:ex
f3 x3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.173: 	f3 x3
//│ ║         	^^^^^
//│ ╟── reference of type `false` is not a 1-element tuple
//│ ║  l.7: 	x1 = false
//│ ║       	     ^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.173: 	f3 x3
//│ ║         	   ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── from type reference:
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from type `false`
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.7: 	x1 = false
//│ ║       	     ^^^^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.8: 	x2 = x1
//│ ║       	     ^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.9: 	x3 = x2
//│ ║       	     ^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.173: 	f3 x3
//│ ║         	   ^^
//│ ╟── [info] flowing from argument of type `(false,)`
//│ ║  l.173: 	f3 x3
//│ ║         	   ^^
//│ ╟── [info] flowing from <nested> of type `(false,)`
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into <nested> of type `int`
//│ ╟── [info] flowing into argument of type `int`
//│ ║  l.80: 	f1 y1 = succ y1
//│ ║        	             ^^
//│ ╟── [info] flowing into reference of type `int`
//│ ║  l.80: 	f1 y1 = succ y1
//│ ║        	             ^^
//│ ╟── [info] flowing into variable of type `int`
//│ ╟── [info] flowing into variable of type `?b`
//│ ╟── [info] flowing into variable of type `?c`
//│ ╟── [info] flowing into variable of type `?d`
//│ ╟── [info] flowing into <nested> of type `?e`
//│ ╟── [info] flowing into argument of type `?f`
//│ ║  l.81: 	f2 y2 = f1 y2
//│ ║        	           ^^
//│ ╟── [info] flowing into reference of type `?g`
//│ ║  l.81: 	f2 y2 = f1 y2
//│ ║        	           ^^
//│ ╟── [info] flowing into variable of type `?h`
//│ ╟── [info] flowing into variable of type `?i`
//│ ╟── [info] flowing into variable of type `?j`
//│ ╟── [info] flowing into variable of type `?k`
//│ ╟── [info] flowing into <nested> of type `?l`
//│ ╟── [info] flowing into argument of type `?m`
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── [info] flowing into reference of type `?n`
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── [info] flowing into variable of type `?o`
//│ ╟── [info] flowing into variable of type `?p`
//│ ╟── [info] flowing into variable of type `?q`
//│ ╟── [info] flowing into variable of type `?r`
//│ ╟── [info] flowing into variable of type `?s`
//│ ╟── [info] flowing into variable of type `?t`
//│ ╙── [info] flowing into expression of type `(?u,)`
//│ res: error | int

















h1 f x = f x
h2 f x = h1 f x
h3 f x = h2 f x
//│ h1: ('a -> 'b) -> 'a -> 'b
//│ h2: ('a -> 'b) -> 'a -> 'b
//│ h3: ('a -> 'b) -> 'a -> 'b

:ex
h3 f3 x3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.284: 	h3 f3 x3
//│ ║         	^^^^^^^^
//│ ╟── reference of type `false` is not a 1-element tuple
//│ ║  l.7: 	x1 = false
//│ ║       	     ^^^^^
//│ ╟── but it flows into reference with expected type `(?a,)`
//│ ║  l.284: 	h3 f3 x3
//│ ║         	      ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.278: 	h3 f x = h2 f x
//│ ║         	              ^
//│ ╟── from type reference:
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from type `false`
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.7: 	x1 = false
//│ ║       	     ^^^^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.8: 	x2 = x1
//│ ║       	     ^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.9: 	x3 = x2
//│ ║       	     ^^
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.284: 	h3 f3 x3
//│ ║         	      ^^
//│ ╟── [info] flowing from argument of type `(false,)`
//│ ║  l.284: 	h3 f3 x3
//│ ║         	      ^^
//│ ╟── [info] flowing from <nested> of type `(false,)`
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into <nested> of type `int`
//│ ╟── [info] flowing into argument of type `int`
//│ ║  l.80: 	f1 y1 = succ y1
//│ ║        	             ^^
//│ ╟── [info] flowing into reference of type `int`
//│ ║  l.80: 	f1 y1 = succ y1
//│ ║        	             ^^
//│ ╟── [info] flowing into variable of type `int`
//│ ╟── [info] flowing into variable of type `?b`
//│ ╟── [info] flowing into variable of type `?c`
//│ ╟── [info] flowing into variable of type `?d`
//│ ╟── [info] flowing into <nested> of type `?e`
//│ ╟── [info] flowing into argument of type `?f`
//│ ║  l.81: 	f2 y2 = f1 y2
//│ ║        	           ^^
//│ ╟── [info] flowing into reference of type `?g`
//│ ║  l.81: 	f2 y2 = f1 y2
//│ ║        	           ^^
//│ ╟── [info] flowing into variable of type `?h`
//│ ╟── [info] flowing into variable of type `?i`
//│ ╟── [info] flowing into variable of type `?j`
//│ ╟── [info] flowing into variable of type `?k`
//│ ╟── [info] flowing into <nested> of type `?l`
//│ ╟── [info] flowing into argument of type `?m`
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── [info] flowing into reference of type `?n`
//│ ║  l.82: 	f3 y3 = f2 y3
//│ ║        	           ^^
//│ ╟── [info] flowing into variable of type `?o`
//│ ╟── [info] flowing into variable of type `?p`
//│ ╟── [info] flowing into variable of type `?q`
//│ ╟── [info] flowing into <nested> of type `?r`
//│ ╟── [info] flowing into reference of type `?s`
//│ ║  l.276: 	h1 f x = f x
//│ ║         	           ^
//│ ╟── [info] flowing into variable of type `?t`
//│ ╟── [info] flowing into variable of type `?u`
//│ ╟── [info] flowing into variable of type `?v`
//│ ╟── [info] flowing into variable of type `?w`
//│ ╟── [info] flowing into <nested> of type `?x`
//│ ╟── [info] flowing into argument of type `?y`
//│ ║  l.277: 	h2 f x = h1 f x
//│ ║         	              ^
//│ ╟── [info] flowing into reference of type `?z`
//│ ║  l.277: 	h2 f x = h1 f x
//│ ║         	              ^
//│ ╟── [info] flowing into variable of type `?a1`
//│ ╟── [info] flowing into variable of type `?b1`
//│ ╟── [info] flowing into variable of type `?c1`
//│ ╟── [info] flowing into variable of type `?d1`
//│ ╟── [info] flowing into <nested> of type `?e1`
//│ ╟── [info] flowing into argument of type `?f1`
//│ ║  l.278: 	h3 f x = h2 f x
//│ ║         	              ^
//│ ╟── [info] flowing into reference of type `?g1`
//│ ║  l.278: 	h3 f x = h2 f x
//│ ║         	              ^
//│ ╟── [info] flowing into variable of type `?h1`
//│ ╟── [info] flowing into variable of type `?i1`
//│ ╟── [info] flowing into variable of type `?j1`
//│ ╟── [info] flowing into variable of type `?k1`
//│ ╟── [info] flowing into variable of type `?l1`
//│ ╟── [info] flowing into variable of type `?m1`
//│ ╙── [info] flowing into expression of type `(?n1,)`
//│ res: error | int




















:ex
(fun x -> succ x) false
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `false` is not a 1-element tuple
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	                  ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	               ^
//│ ╟── from type reference:
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from type `false`
//│ ╟── [info] flowing from reference of type `false`
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	                  ^^^^^
//│ ╟── [info] flowing from argument of type `(false,)`
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	                  ^^^^^
//│ ╟── [info] flowing from <nested> of type `(false,)`
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into <nested> of type `int`
//│ ╟── [info] flowing into argument of type `int`
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	               ^
//│ ╟── [info] flowing into reference of type `int`
//│ ║  l.420: 	(fun x -> succ x) false
//│ ║         	               ^
//│ ╟── [info] flowing into variable of type `int`
//│ ╟── [info] flowing into variable of type `?a`
//│ ╟── [info] flowing into variable of type `?b`
//│ ╙── [info] flowing into expression of type `(?c,)`
//│ res: error | int










// :d
:ex
rec def x = add x
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.481: 	rec def x = add x
//│ ║         	            ^^^^^
//│ ╟── application of type `int -> int` does not match type `?x`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.481: 	rec def x = add x
//│ ║         	                ^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from expression of type `int -> int`
//│ ╟── [info] flowing from <nested> of type `int -> int`
//│ ╟── [info] flowing from application of type `?a`
//│ ║  l.481: 	rec def x = add x
//│ ║         	            ^^^^^
//│ ╟── [info] flowing into type `int`
//│ ╟── [info] flowing into type `int`
//│ ╟── [info] flowing into type `int`
//│ ╟── [info] flowing into <nested> of type `int`
//│ ╟── [info] flowing into argument of type `int`
//│ ║  l.481: 	rec def x = add x
//│ ║         	                ^
//│ ╟── [info] flowing into reference of type `int`
//│ ║  l.481: 	rec def x = add x
//│ ║         	                ^
//│ ╙── [info] flowing into expression of type `?x0`
//│ x: int -> int







def foo: int | string
//│ foo: int | string

:ex
succ foo
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.518: 	succ foo
//│ ║         	^^^^^^^^
//│ ╟── type `string` is not a 1-element tuple
//│ ║  l.514: 	def foo: int | string
//│ ║         	               ^^^^^^
//│ ╟── but it flows into reference with expected type `(int,)`
//│ ║  l.518: 	succ foo
//│ ║         	     ^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from type `string`
//│ ║  l.514: 	def foo: int | string
//│ ║         	               ^^^^^^
//│ ╟── [info] flowing from type `int | string`
//│ ║  l.514: 	def foo: int | string
//│ ║         	         ^^^^^^^^^^^^
//│ ╟── [info] flowing from reference of type `int | string`
//│ ║  l.518: 	succ foo
//│ ║         	     ^^^
//│ ╟── [info] flowing from argument of type `(int | string,)`
//│ ║  l.518: 	succ foo
//│ ║         	     ^^^
//│ ╟── [info] flowing from <nested> of type `(int | string,)`
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `int`
//│ ║  l.3: 	def succ: int -> int
//│ ║       	          ^^^
//│ ╟── [info] flowing into type `(int,)`
//│ ║  l.3: 	def succ: int -> int
//│ ╙──     	          ^^^
//│ res: error | int











class A
class B
//│ Defined class A
//│ Defined class B

def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ty00: (A & 'a | B & 'b) -> ('a, 'b,)

def ty11: ('a & A | 'a & B) -> ('a, 'a)
//│ ty11: ('a & (A | B)) -> ('a, 'a,)

ty11 = ty00
//│ (A & 'a | B & 'b) -> ('a, 'b,)
//│   <:  ty11:
//│ ('a & (A | B)) -> ('a, 'a,)

// :d
:ex
ty00 = ty11
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.587: 	ty00 = ty11
//│ ║         	^^^^^^^^^^^
//│ ╟── type `B & 'b` is not an instance of type `'a`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	                    ^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	                                ^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from expression of type `B & 'b`
//│ ╟── [info] flowing from type `B & 'b`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	                    ^^^^^^
//│ ╟── [info] flowing from type `B & 'b`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	          ^^^^^^^^^^^^^^^^^
//│ ╟── [info] flowing from <nested> of type `B & 'b`
//│ ╟── [info] flowing from type `B & 'b`
//│ ║  l.577: 	def ty11: ('a & A | 'a & B) -> ('a, 'a)
//│ ║         	          ^^^^^^^^^^^^^^^^^
//│ ╟── [info] flowing from expression of type `?a`
//│ ╟── [info] flowing from type `?a0`
//│ ║  l.577: 	def ty11: ('a & A | 'a & B) -> ('a, 'a)
//│ ║         	                                ^^
//│ ╟── [info] flowing from <nested> of type `?a1`
//│ ╟── [info] flowing into expression of type `'a`
//│ ╟── [info] flowing into expression of type `'a`
//│ ╟── [info] flowing into expression of type `'a`
//│ ╟── [info] flowing into expression of type `'a`
//│ ╟── [info] flowing into expression of type `'a`
//│ ╟── [info] flowing into expression of type `'a`
//│ ╟── [info] flowing into type `'a`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ╙──       	                                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.587: 	ty00 = ty11
//│ ║         	^^^^^^^^^^^
//│ ╟── type `A & 'a` is not an instance of type `'b`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	           ^^^^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	                                    ^^
//│ ╟── ========= Additional explanations below =========
//│ ╟── [info] flowing from expression of type `A & 'a`
//│ ╟── [info] flowing from type `A & 'a`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	           ^^^^^^
//│ ╟── [info] flowing from type `A & 'a`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ║         	          ^^^^^^^^^^^^^^^^^
//│ ╟── [info] flowing from <nested> of type `A & 'a`
//│ ╟── [info] flowing from type `A & 'a`
//│ ║  l.577: 	def ty11: ('a & A | 'a & B) -> ('a, 'a)
//│ ║         	          ^^^^^^^^^^^^^^^^^
//│ ╟── [info] flowing from expression of type `?a`
//│ ╟── [info] flowing from type `?a0`
//│ ║  l.577: 	def ty11: ('a & A | 'a & B) -> ('a, 'a)
//│ ║         	                                    ^^
//│ ╟── [info] flowing from <nested> of type `?a1`
//│ ╟── [info] flowing into expression of type `'b`
//│ ╟── [info] flowing into expression of type `'b`
//│ ╟── [info] flowing into expression of type `'b`
//│ ╟── [info] flowing into expression of type `'b`
//│ ╟── [info] flowing into expression of type `'b`
//│ ╟── [info] flowing into expression of type `'b`
//│ ╟── [info] flowing into type `'b`
//│ ║  l.574: 	def ty00: ('a & A | 'b & B) -> ('a, 'b)
//│ ╙──       	                                    ^^
//│ ('a & (A | B)) -> ('a, 'a,)
//│   <:  ty00:
//│ (A & 'a | B & 'b) -> ('a, 'b,)

















